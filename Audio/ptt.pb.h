// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ptt.proto

#ifndef PROTOBUF_ptt_2eproto__INCLUDED
#define PROTOBUF_ptt_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
class Call;
class CallDefaultTypeInternal;
extern CallDefaultTypeInternal _Call_default_instance_;
class CallAck;
class CallAckDefaultTypeInternal;
extern CallAckDefaultTypeInternal _CallAck_default_instance_;
class Configure;
class ConfigureDefaultTypeInternal;
extern ConfigureDefaultTypeInternal _Configure_default_instance_;
class CurrentGroup;
class CurrentGroupDefaultTypeInternal;
extern CurrentGroupDefaultTypeInternal _CurrentGroup_default_instance_;
class Group;
class GroupDefaultTypeInternal;
extern GroupDefaultTypeInternal _Group_default_instance_;
class GroupListChanged;
class GroupListChangedDefaultTypeInternal;
extern GroupListChangedDefaultTypeInternal _GroupListChanged_default_instance_;
class JoinGroup;
class JoinGroupDefaultTypeInternal;
extern JoinGroupDefaultTypeInternal _JoinGroup_default_instance_;
class JoinGroupAck;
class JoinGroupAckDefaultTypeInternal;
extern JoinGroupAckDefaultTypeInternal _JoinGroupAck_default_instance_;
class Kickout;
class KickoutDefaultTypeInternal;
extern KickoutDefaultTypeInternal _Kickout_default_instance_;
class LeaveGroup;
class LeaveGroupDefaultTypeInternal;
extern LeaveGroupDefaultTypeInternal _LeaveGroup_default_instance_;
class LeaveGroupAck;
class LeaveGroupAckDefaultTypeInternal;
extern LeaveGroupAckDefaultTypeInternal _LeaveGroupAck_default_instance_;
class Login;
class LoginDefaultTypeInternal;
extern LoginDefaultTypeInternal _Login_default_instance_;
class LoginAck;
class LoginAckDefaultTypeInternal;
extern LoginAckDefaultTypeInternal _LoginAck_default_instance_;
class Logout;
class LogoutDefaultTypeInternal;
extern LogoutDefaultTypeInternal _Logout_default_instance_;
class LogoutAck;
class LogoutAckDefaultTypeInternal;
extern LogoutAckDefaultTypeInternal _LogoutAck_default_instance_;
class LostMic;
class LostMicDefaultTypeInternal;
extern LostMicDefaultTypeInternal _LostMic_default_instance_;
class MemberGetMic;
class MemberGetMicDefaultTypeInternal;
extern MemberGetMicDefaultTypeInternal _MemberGetMic_default_instance_;
class MemberLostMic;
class MemberLostMicDefaultTypeInternal;
extern MemberLostMicDefaultTypeInternal _MemberLostMic_default_instance_;
class Ping;
class PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
class PingAck;
class PingAckDefaultTypeInternal;
extern PingAckDefaultTypeInternal _PingAck_default_instance_;
class QueryGroup;
class QueryGroupDefaultTypeInternal;
extern QueryGroupDefaultTypeInternal _QueryGroup_default_instance_;
class QueryGroupAck;
class QueryGroupAckDefaultTypeInternal;
extern QueryGroupAckDefaultTypeInternal _QueryGroupAck_default_instance_;
class QueryMembers;
class QueryMembersDefaultTypeInternal;
extern QueryMembersDefaultTypeInternal _QueryMembers_default_instance_;
class QueryMembersAck;
class QueryMembersAckDefaultTypeInternal;
extern QueryMembersAckDefaultTypeInternal _QueryMembersAck_default_instance_;
class QueryMembersAck_GroupMembers;
class QueryMembersAck_GroupMembersDefaultTypeInternal;
extern QueryMembersAck_GroupMembersDefaultTypeInternal _QueryMembersAck_GroupMembers_default_instance_;
class Reconfigured;
class ReconfiguredDefaultTypeInternal;
extern ReconfiguredDefaultTypeInternal _Reconfigured_default_instance_;
class ReleaseMic;
class ReleaseMicDefaultTypeInternal;
extern ReleaseMicDefaultTypeInternal _ReleaseMic_default_instance_;
class ReleaseMicAck;
class ReleaseMicAckDefaultTypeInternal;
extern ReleaseMicAckDefaultTypeInternal _ReleaseMicAck_default_instance_;
class ReportLocation;
class ReportLocationDefaultTypeInternal;
extern ReportLocationDefaultTypeInternal _ReportLocation_default_instance_;
class ReportLocationAck;
class ReportLocationAckDefaultTypeInternal;
extern ReportLocationAckDefaultTypeInternal _ReportLocationAck_default_instance_;
class RequestMic;
class RequestMicDefaultTypeInternal;
extern RequestMicDefaultTypeInternal _RequestMic_default_instance_;
class RequestMicAck;
class RequestMicAckDefaultTypeInternal;
extern RequestMicAckDefaultTypeInternal _RequestMicAck_default_instance_;
class ServerInfo;
class ServerInfoDefaultTypeInternal;
extern ServerInfoDefaultTypeInternal _ServerInfo_default_instance_;
class TempCallArrived;
class TempCallArrivedDefaultTypeInternal;
extern TempCallArrivedDefaultTypeInternal _TempCallArrived_default_instance_;
class TempCallStatus;
class TempCallStatusDefaultTypeInternal;
extern TempCallStatusDefaultTypeInternal _TempCallStatus_default_instance_;
class User;
class UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;

namespace protobuf_ptt_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_ptt_2eproto

enum Group_GroupType {
  Group_GroupType_BUILTIN = 0,
  Group_GroupType_STATIC = 1,
  Group_GroupType_TEMP = 2
};
bool Group_GroupType_IsValid(int value);
const Group_GroupType Group_GroupType_GroupType_MIN = Group_GroupType_BUILTIN;
const Group_GroupType Group_GroupType_GroupType_MAX = Group_GroupType_TEMP;
const int Group_GroupType_GroupType_ARRAYSIZE = Group_GroupType_GroupType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Group_GroupType_descriptor();
inline const ::std::string& Group_GroupType_Name(Group_GroupType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Group_GroupType_descriptor(), value);
}
inline bool Group_GroupType_Parse(
    const ::std::string& name, Group_GroupType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Group_GroupType>(
    Group_GroupType_descriptor(), name, value);
}
enum QueryGroup_DetailLevel {
  QueryGroup_DetailLevel_ONLY_ID = 0,
  QueryGroup_DetailLevel_GROUP_INFO = 1
};
bool QueryGroup_DetailLevel_IsValid(int value);
const QueryGroup_DetailLevel QueryGroup_DetailLevel_DetailLevel_MIN = QueryGroup_DetailLevel_ONLY_ID;
const QueryGroup_DetailLevel QueryGroup_DetailLevel_DetailLevel_MAX = QueryGroup_DetailLevel_GROUP_INFO;
const int QueryGroup_DetailLevel_DetailLevel_ARRAYSIZE = QueryGroup_DetailLevel_DetailLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* QueryGroup_DetailLevel_descriptor();
inline const ::std::string& QueryGroup_DetailLevel_Name(QueryGroup_DetailLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    QueryGroup_DetailLevel_descriptor(), value);
}
inline bool QueryGroup_DetailLevel_Parse(
    const ::std::string& name, QueryGroup_DetailLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<QueryGroup_DetailLevel>(
    QueryGroup_DetailLevel_descriptor(), name, value);
}
enum QueryMembers_DetailLevel {
  QueryMembers_DetailLevel_ONLY_ID = 0,
  QueryMembers_DetailLevel_USER_INFO = 1
};
bool QueryMembers_DetailLevel_IsValid(int value);
const QueryMembers_DetailLevel QueryMembers_DetailLevel_DetailLevel_MIN = QueryMembers_DetailLevel_ONLY_ID;
const QueryMembers_DetailLevel QueryMembers_DetailLevel_DetailLevel_MAX = QueryMembers_DetailLevel_USER_INFO;
const int QueryMembers_DetailLevel_DetailLevel_ARRAYSIZE = QueryMembers_DetailLevel_DetailLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* QueryMembers_DetailLevel_descriptor();
inline const ::std::string& QueryMembers_DetailLevel_Name(QueryMembers_DetailLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    QueryMembers_DetailLevel_descriptor(), value);
}
inline bool QueryMembers_DetailLevel_Parse(
    const ::std::string& name, QueryMembers_DetailLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<QueryMembers_DetailLevel>(
    QueryMembers_DetailLevel_descriptor(), name, value);
}
// ===================================================================

class User : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:User) */ {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(User&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const User& default_instance();

  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(User* other);
  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline User* New() const PROTOBUF_FINAL { return New(NULL); }

  User* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(User* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required uint32 uid = 1;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 1;
  ::google::protobuf::uint32 uid() const;
  void set_uid(::google::protobuf::uint32 value);

  // optional bool online = 3;
  bool has_online() const;
  void clear_online();
  static const int kOnlineFieldNumber = 3;
  bool online() const;
  void set_online(bool value);

  // optional uint32 usr_attri = 4;
  bool has_usr_attri() const;
  void clear_usr_attri();
  static const int kUsrAttriFieldNumber = 4;
  ::google::protobuf::uint32 usr_attri() const;
  void set_usr_attri(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:User)
 private:
  void set_has_uid();
  void clear_has_uid();
  void set_has_name();
  void clear_has_name();
  void set_has_online();
  void clear_has_online();
  void set_has_usr_attri();
  void clear_has_usr_attri();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 uid_;
  bool online_;
  ::google::protobuf::uint32 usr_attri_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Group : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Group) */ {
 public:
  Group();
  virtual ~Group();

  Group(const Group& from);

  inline Group& operator=(const Group& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Group(Group&& from) noexcept
    : Group() {
    *this = ::std::move(from);
  }

  inline Group& operator=(Group&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Group& default_instance();

  static inline const Group* internal_default_instance() {
    return reinterpret_cast<const Group*>(
               &_Group_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Group* other);
  friend void swap(Group& a, Group& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Group* New() const PROTOBUF_FINAL { return New(NULL); }

  Group* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Group& from);
  void MergeFrom(const Group& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Group* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Group_GroupType GroupType;
  static const GroupType BUILTIN =
    Group_GroupType_BUILTIN;
  static const GroupType STATIC =
    Group_GroupType_STATIC;
  static const GroupType TEMP =
    Group_GroupType_TEMP;
  static inline bool GroupType_IsValid(int value) {
    return Group_GroupType_IsValid(value);
  }
  static const GroupType GroupType_MIN =
    Group_GroupType_GroupType_MIN;
  static const GroupType GroupType_MAX =
    Group_GroupType_GroupType_MAX;
  static const int GroupType_ARRAYSIZE =
    Group_GroupType_GroupType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GroupType_descriptor() {
    return Group_GroupType_descriptor();
  }
  static inline const ::std::string& GroupType_Name(GroupType value) {
    return Group_GroupType_Name(value);
  }
  static inline bool GroupType_Parse(const ::std::string& name,
      GroupType* value) {
    return Group_GroupType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required uint32 gid = 1;
  bool has_gid() const;
  void clear_gid();
  static const int kGidFieldNumber = 1;
  ::google::protobuf::uint32 gid() const;
  void set_gid(::google::protobuf::uint32 value);

  // required uint32 n_members = 3;
  bool has_n_members() const;
  void clear_n_members();
  static const int kNMembersFieldNumber = 3;
  ::google::protobuf::uint32 n_members() const;
  void set_n_members(::google::protobuf::uint32 value);

  // optional .Group.GroupType type = 4 [default = STATIC];
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::Group_GroupType type() const;
  void set_type(::Group_GroupType value);

  // @@protoc_insertion_point(class_scope:Group)
 private:
  void set_has_gid();
  void clear_has_gid();
  void set_has_name();
  void clear_has_name();
  void set_has_n_members();
  void clear_has_n_members();
  void set_has_type();
  void clear_has_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 gid_;
  ::google::protobuf::uint32 n_members_;
  int type_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Configure : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Configure) */ {
 public:
  Configure();
  virtual ~Configure();

  Configure(const Configure& from);

  inline Configure& operator=(const Configure& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Configure(Configure&& from) noexcept
    : Configure() {
    *this = ::std::move(from);
  }

  inline Configure& operator=(Configure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Configure& default_instance();

  static inline const Configure* internal_default_instance() {
    return reinterpret_cast<const Configure*>(
               &_Configure_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Configure* other);
  friend void swap(Configure& a, Configure& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Configure* New() const PROTOBUF_FINAL { return New(NULL); }

  Configure* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Configure& from);
  void MergeFrom(const Configure& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Configure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 default_group = 1;
  bool has_default_group() const;
  void clear_default_group();
  static const int kDefaultGroupFieldNumber = 1;
  ::google::protobuf::uint32 default_group() const;
  void set_default_group(::google::protobuf::uint32 value);

  // optional uint32 loc_report_period = 2;
  bool has_loc_report_period() const;
  void clear_loc_report_period();
  static const int kLocReportPeriodFieldNumber = 2;
  ::google::protobuf::uint32 loc_report_period() const;
  void set_loc_report_period(::google::protobuf::uint32 value);

  // optional uint32 cfg_ptt_timeout = 4;
  bool has_cfg_ptt_timeout() const;
  void clear_cfg_ptt_timeout();
  static const int kCfgPttTimeoutFieldNumber = 4;
  ::google::protobuf::uint32 cfg_ptt_timeout() const;
  void set_cfg_ptt_timeout(::google::protobuf::uint32 value);

  // optional uint32 heart_inter = 5;
  bool has_heart_inter() const;
  void clear_heart_inter();
  static const int kHeartInterFieldNumber = 5;
  ::google::protobuf::uint32 heart_inter() const;
  void set_heart_inter(::google::protobuf::uint32 value);

  // optional bool audio_enabled = 3 [default = true];
  bool has_audio_enabled() const;
  void clear_audio_enabled();
  static const int kAudioEnabledFieldNumber = 3;
  bool audio_enabled() const;
  void set_audio_enabled(bool value);

  // @@protoc_insertion_point(class_scope:Configure)
 private:
  void set_has_default_group();
  void clear_has_default_group();
  void set_has_loc_report_period();
  void clear_has_loc_report_period();
  void set_has_audio_enabled();
  void clear_has_audio_enabled();
  void set_has_cfg_ptt_timeout();
  void clear_has_cfg_ptt_timeout();
  void set_has_heart_inter();
  void clear_has_heart_inter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 default_group_;
  ::google::protobuf::uint32 loc_report_period_;
  ::google::protobuf::uint32 cfg_ptt_timeout_;
  ::google::protobuf::uint32 heart_inter_;
  bool audio_enabled_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ServerInfo) */ {
 public:
  ServerInfo();
  virtual ~ServerInfo();

  ServerInfo(const ServerInfo& from);

  inline ServerInfo& operator=(const ServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerInfo(ServerInfo&& from) noexcept
    : ServerInfo() {
    *this = ::std::move(from);
  }

  inline ServerInfo& operator=(ServerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerInfo& default_instance();

  static inline const ServerInfo* internal_default_instance() {
    return reinterpret_cast<const ServerInfo*>(
               &_ServerInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ServerInfo* other);
  friend void swap(ServerInfo& a, ServerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ServerInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ServerInfo& from);
  void MergeFrom(const ServerInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ServerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // required uint32 port = 2;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ServerInfo)
 private:
  void set_has_address();
  void clear_has_address();
  void set_has_port();
  void clear_has_port();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::uint32 port_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Login : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Login) */ {
 public:
  Login();
  virtual ~Login();

  Login(const Login& from);

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Login(Login&& from) noexcept
    : Login() {
    *this = ::std::move(from);
  }

  inline Login& operator=(Login&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Login& default_instance();

  static inline const Login* internal_default_instance() {
    return reinterpret_cast<const Login*>(
               &_Login_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Login* other);
  friend void swap(Login& a, Login& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Login* New() const PROTOBUF_FINAL { return New(NULL); }

  Login* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Login* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // optional string password = 2;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // required string platform = 4;
  bool has_platform() const;
  void clear_platform();
  static const int kPlatformFieldNumber = 4;
  const ::std::string& platform() const;
  void set_platform(const ::std::string& value);
  #if LANG_CXX11
  void set_platform(::std::string&& value);
  #endif
  void set_platform(const char* value);
  void set_platform(const char* value, size_t size);
  ::std::string* mutable_platform();
  ::std::string* release_platform();
  void set_allocated_platform(::std::string* platform);

  // required string device = 5;
  bool has_device() const;
  void clear_device();
  static const int kDeviceFieldNumber = 5;
  const ::std::string& device() const;
  void set_device(const ::std::string& value);
  #if LANG_CXX11
  void set_device(::std::string&& value);
  #endif
  void set_device(const char* value);
  void set_device(const char* value, size_t size);
  ::std::string* mutable_device();
  ::std::string* release_device();
  void set_allocated_device(::std::string* device);

  // optional string meid = 6;
  bool has_meid() const;
  void clear_meid();
  static const int kMeidFieldNumber = 6;
  const ::std::string& meid() const;
  void set_meid(const ::std::string& value);
  #if LANG_CXX11
  void set_meid(::std::string&& value);
  #endif
  void set_meid(const char* value);
  void set_meid(const char* value, size_t size);
  ::std::string* mutable_meid();
  ::std::string* release_meid();
  void set_allocated_meid(::std::string* meid);

  // optional int32 version = 3;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // optional uint32 expect_payload = 7 [default = 101];
  bool has_expect_payload() const;
  void clear_expect_payload();
  static const int kExpectPayloadFieldNumber = 7;
  ::google::protobuf::uint32 expect_payload() const;
  void set_expect_payload(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Login)
 private:
  void set_has_account();
  void clear_has_account();
  void set_has_password();
  void clear_has_password();
  void set_has_version();
  void clear_has_version();
  void set_has_platform();
  void clear_has_platform();
  void set_has_device();
  void clear_has_device();
  void set_has_meid();
  void clear_has_meid();
  void set_has_expect_payload();
  void clear_has_expect_payload();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr platform_;
  ::google::protobuf::internal::ArenaStringPtr device_;
  ::google::protobuf::internal::ArenaStringPtr meid_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::uint32 expect_payload_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoginAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LoginAck) */ {
 public:
  LoginAck();
  virtual ~LoginAck();

  LoginAck(const LoginAck& from);

  inline LoginAck& operator=(const LoginAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginAck(LoginAck&& from) noexcept
    : LoginAck() {
    *this = ::std::move(from);
  }

  inline LoginAck& operator=(LoginAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginAck& default_instance();

  static inline const LoginAck* internal_default_instance() {
    return reinterpret_cast<const LoginAck*>(
               &_LoginAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(LoginAck* other);
  friend void swap(LoginAck& a, LoginAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginAck* New() const PROTOBUF_FINAL { return New(NULL); }

  LoginAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoginAck& from);
  void MergeFrom(const LoginAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoginAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .User usr = 2;
  bool has_usr() const;
  void clear_usr();
  static const int kUsrFieldNumber = 2;
  const ::User& usr() const;
  ::User* mutable_usr();
  ::User* release_usr();
  void set_allocated_usr(::User* usr);

  // required .Configure conf = 3;
  bool has_conf() const;
  void clear_conf();
  static const int kConfFieldNumber = 3;
  const ::Configure& conf() const;
  ::Configure* mutable_conf();
  ::Configure* release_conf();
  void set_allocated_conf(::Configure* conf);

  // optional .ServerInfo tcp_server = 4;
  bool has_tcp_server() const;
  void clear_tcp_server();
  static const int kTcpServerFieldNumber = 4;
  const ::ServerInfo& tcp_server() const;
  ::ServerInfo* mutable_tcp_server();
  ::ServerInfo* release_tcp_server();
  void set_allocated_tcp_server(::ServerInfo* tcp_server);

  // optional .ServerInfo udp_server = 5;
  bool has_udp_server() const;
  void clear_udp_server();
  static const int kUdpServerFieldNumber = 5;
  const ::ServerInfo& udp_server() const;
  ::ServerInfo* mutable_udp_server();
  ::ServerInfo* release_udp_server();
  void set_allocated_udp_server(::ServerInfo* udp_server);

  // optional .ServerInfo update_server = 6;
  bool has_update_server() const;
  void clear_update_server();
  static const int kUpdateServerFieldNumber = 6;
  const ::ServerInfo& update_server() const;
  ::ServerInfo* mutable_update_server();
  ::ServerInfo* release_update_server();
  void set_allocated_update_server(::ServerInfo* update_server);

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // optional uint32 cookie = 7;
  bool has_cookie() const;
  void clear_cookie();
  static const int kCookieFieldNumber = 7;
  ::google::protobuf::uint32 cookie() const;
  void set_cookie(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:LoginAck)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_usr();
  void clear_has_usr();
  void set_has_conf();
  void clear_has_conf();
  void set_has_tcp_server();
  void clear_has_tcp_server();
  void set_has_udp_server();
  void clear_has_udp_server();
  void set_has_update_server();
  void clear_has_update_server();
  void set_has_cookie();
  void clear_has_cookie();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::User* usr_;
  ::Configure* conf_;
  ::ServerInfo* tcp_server_;
  ::ServerInfo* udp_server_;
  ::ServerInfo* update_server_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::uint32 cookie_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QueryGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:QueryGroup) */ {
 public:
  QueryGroup();
  virtual ~QueryGroup();

  QueryGroup(const QueryGroup& from);

  inline QueryGroup& operator=(const QueryGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QueryGroup(QueryGroup&& from) noexcept
    : QueryGroup() {
    *this = ::std::move(from);
  }

  inline QueryGroup& operator=(QueryGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryGroup& default_instance();

  static inline const QueryGroup* internal_default_instance() {
    return reinterpret_cast<const QueryGroup*>(
               &_QueryGroup_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(QueryGroup* other);
  friend void swap(QueryGroup& a, QueryGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueryGroup* New() const PROTOBUF_FINAL { return New(NULL); }

  QueryGroup* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const QueryGroup& from);
  void MergeFrom(const QueryGroup& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(QueryGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef QueryGroup_DetailLevel DetailLevel;
  static const DetailLevel ONLY_ID =
    QueryGroup_DetailLevel_ONLY_ID;
  static const DetailLevel GROUP_INFO =
    QueryGroup_DetailLevel_GROUP_INFO;
  static inline bool DetailLevel_IsValid(int value) {
    return QueryGroup_DetailLevel_IsValid(value);
  }
  static const DetailLevel DetailLevel_MIN =
    QueryGroup_DetailLevel_DetailLevel_MIN;
  static const DetailLevel DetailLevel_MAX =
    QueryGroup_DetailLevel_DetailLevel_MAX;
  static const int DetailLevel_ARRAYSIZE =
    QueryGroup_DetailLevel_DetailLevel_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DetailLevel_descriptor() {
    return QueryGroup_DetailLevel_descriptor();
  }
  static inline const ::std::string& DetailLevel_Name(DetailLevel value) {
    return QueryGroup_DetailLevel_Name(value);
  }
  static inline bool DetailLevel_Parse(const ::std::string& name,
      DetailLevel* value) {
    return QueryGroup_DetailLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bool include_temp = 2 [default = false];
  bool has_include_temp() const;
  void clear_include_temp();
  static const int kIncludeTempFieldNumber = 2;
  bool include_temp() const;
  void set_include_temp(bool value);

  // required .QueryGroup.DetailLevel detail = 1 [default = GROUP_INFO];
  bool has_detail() const;
  void clear_detail();
  static const int kDetailFieldNumber = 1;
  ::QueryGroup_DetailLevel detail() const;
  void set_detail(::QueryGroup_DetailLevel value);

  // @@protoc_insertion_point(class_scope:QueryGroup)
 private:
  void set_has_detail();
  void clear_has_detail();
  void set_has_include_temp();
  void clear_has_include_temp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool include_temp_;
  int detail_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QueryGroupAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:QueryGroupAck) */ {
 public:
  QueryGroupAck();
  virtual ~QueryGroupAck();

  QueryGroupAck(const QueryGroupAck& from);

  inline QueryGroupAck& operator=(const QueryGroupAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QueryGroupAck(QueryGroupAck&& from) noexcept
    : QueryGroupAck() {
    *this = ::std::move(from);
  }

  inline QueryGroupAck& operator=(QueryGroupAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryGroupAck& default_instance();

  static inline const QueryGroupAck* internal_default_instance() {
    return reinterpret_cast<const QueryGroupAck*>(
               &_QueryGroupAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(QueryGroupAck* other);
  friend void swap(QueryGroupAck& a, QueryGroupAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueryGroupAck* New() const PROTOBUF_FINAL { return New(NULL); }

  QueryGroupAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const QueryGroupAck& from);
  void MergeFrom(const QueryGroupAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(QueryGroupAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Group groups = 2;
  int groups_size() const;
  void clear_groups();
  static const int kGroupsFieldNumber = 2;
  const ::Group& groups(int index) const;
  ::Group* mutable_groups(int index);
  ::Group* add_groups();
  ::google::protobuf::RepeatedPtrField< ::Group >*
      mutable_groups();
  const ::google::protobuf::RepeatedPtrField< ::Group >&
      groups() const;

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:QueryGroupAck)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Group > groups_;
  ::google::protobuf::int32 result_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QueryMembers : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:QueryMembers) */ {
 public:
  QueryMembers();
  virtual ~QueryMembers();

  QueryMembers(const QueryMembers& from);

  inline QueryMembers& operator=(const QueryMembers& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QueryMembers(QueryMembers&& from) noexcept
    : QueryMembers() {
    *this = ::std::move(from);
  }

  inline QueryMembers& operator=(QueryMembers&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryMembers& default_instance();

  static inline const QueryMembers* internal_default_instance() {
    return reinterpret_cast<const QueryMembers*>(
               &_QueryMembers_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(QueryMembers* other);
  friend void swap(QueryMembers& a, QueryMembers& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueryMembers* New() const PROTOBUF_FINAL { return New(NULL); }

  QueryMembers* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const QueryMembers& from);
  void MergeFrom(const QueryMembers& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(QueryMembers* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef QueryMembers_DetailLevel DetailLevel;
  static const DetailLevel ONLY_ID =
    QueryMembers_DetailLevel_ONLY_ID;
  static const DetailLevel USER_INFO =
    QueryMembers_DetailLevel_USER_INFO;
  static inline bool DetailLevel_IsValid(int value) {
    return QueryMembers_DetailLevel_IsValid(value);
  }
  static const DetailLevel DetailLevel_MIN =
    QueryMembers_DetailLevel_DetailLevel_MIN;
  static const DetailLevel DetailLevel_MAX =
    QueryMembers_DetailLevel_DetailLevel_MAX;
  static const int DetailLevel_ARRAYSIZE =
    QueryMembers_DetailLevel_DetailLevel_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DetailLevel_descriptor() {
    return QueryMembers_DetailLevel_descriptor();
  }
  static inline const ::std::string& DetailLevel_Name(DetailLevel value) {
    return QueryMembers_DetailLevel_Name(value);
  }
  static inline bool DetailLevel_Parse(const ::std::string& name,
      DetailLevel* value) {
    return QueryMembers_DetailLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated uint32 gids = 1;
  int gids_size() const;
  void clear_gids();
  static const int kGidsFieldNumber = 1;
  ::google::protobuf::uint32 gids(int index) const;
  void set_gids(int index, ::google::protobuf::uint32 value);
  void add_gids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      gids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_gids();

  // optional .QueryMembers.DetailLevel detail = 2 [default = USER_INFO];
  bool has_detail() const;
  void clear_detail();
  static const int kDetailFieldNumber = 2;
  ::QueryMembers_DetailLevel detail() const;
  void set_detail(::QueryMembers_DetailLevel value);

  // @@protoc_insertion_point(class_scope:QueryMembers)
 private:
  void set_has_detail();
  void clear_has_detail();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > gids_;
  int detail_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QueryMembersAck_GroupMembers : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:QueryMembersAck.GroupMembers) */ {
 public:
  QueryMembersAck_GroupMembers();
  virtual ~QueryMembersAck_GroupMembers();

  QueryMembersAck_GroupMembers(const QueryMembersAck_GroupMembers& from);

  inline QueryMembersAck_GroupMembers& operator=(const QueryMembersAck_GroupMembers& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QueryMembersAck_GroupMembers(QueryMembersAck_GroupMembers&& from) noexcept
    : QueryMembersAck_GroupMembers() {
    *this = ::std::move(from);
  }

  inline QueryMembersAck_GroupMembers& operator=(QueryMembersAck_GroupMembers&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryMembersAck_GroupMembers& default_instance();

  static inline const QueryMembersAck_GroupMembers* internal_default_instance() {
    return reinterpret_cast<const QueryMembersAck_GroupMembers*>(
               &_QueryMembersAck_GroupMembers_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(QueryMembersAck_GroupMembers* other);
  friend void swap(QueryMembersAck_GroupMembers& a, QueryMembersAck_GroupMembers& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueryMembersAck_GroupMembers* New() const PROTOBUF_FINAL { return New(NULL); }

  QueryMembersAck_GroupMembers* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const QueryMembersAck_GroupMembers& from);
  void MergeFrom(const QueryMembersAck_GroupMembers& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(QueryMembersAck_GroupMembers* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 ingroups = 2;
  int ingroups_size() const;
  void clear_ingroups();
  static const int kIngroupsFieldNumber = 2;
  ::google::protobuf::uint32 ingroups(int index) const;
  void set_ingroups(int index, ::google::protobuf::uint32 value);
  void add_ingroups(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ingroups() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ingroups();

  // repeated uint32 outgroups = 3;
  int outgroups_size() const;
  void clear_outgroups();
  static const int kOutgroupsFieldNumber = 3;
  ::google::protobuf::uint32 outgroups(int index) const;
  void set_outgroups(int index, ::google::protobuf::uint32 value);
  void add_outgroups(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      outgroups() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_outgroups();

  // repeated .User members = 4;
  int members_size() const;
  void clear_members();
  static const int kMembersFieldNumber = 4;
  const ::User& members(int index) const;
  ::User* mutable_members(int index);
  ::User* add_members();
  ::google::protobuf::RepeatedPtrField< ::User >*
      mutable_members();
  const ::google::protobuf::RepeatedPtrField< ::User >&
      members() const;

  // required uint32 gid = 1;
  bool has_gid() const;
  void clear_gid();
  static const int kGidFieldNumber = 1;
  ::google::protobuf::uint32 gid() const;
  void set_gid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:QueryMembersAck.GroupMembers)
 private:
  void set_has_gid();
  void clear_has_gid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ingroups_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > outgroups_;
  ::google::protobuf::RepeatedPtrField< ::User > members_;
  ::google::protobuf::uint32 gid_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QueryMembersAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:QueryMembersAck) */ {
 public:
  QueryMembersAck();
  virtual ~QueryMembersAck();

  QueryMembersAck(const QueryMembersAck& from);

  inline QueryMembersAck& operator=(const QueryMembersAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QueryMembersAck(QueryMembersAck&& from) noexcept
    : QueryMembersAck() {
    *this = ::std::move(from);
  }

  inline QueryMembersAck& operator=(QueryMembersAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryMembersAck& default_instance();

  static inline const QueryMembersAck* internal_default_instance() {
    return reinterpret_cast<const QueryMembersAck*>(
               &_QueryMembersAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(QueryMembersAck* other);
  friend void swap(QueryMembersAck& a, QueryMembersAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueryMembersAck* New() const PROTOBUF_FINAL { return New(NULL); }

  QueryMembersAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const QueryMembersAck& from);
  void MergeFrom(const QueryMembersAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(QueryMembersAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef QueryMembersAck_GroupMembers GroupMembers;

  // accessors -------------------------------------------------------

  // repeated .QueryMembersAck.GroupMembers members = 2;
  int members_size() const;
  void clear_members();
  static const int kMembersFieldNumber = 2;
  const ::QueryMembersAck_GroupMembers& members(int index) const;
  ::QueryMembersAck_GroupMembers* mutable_members(int index);
  ::QueryMembersAck_GroupMembers* add_members();
  ::google::protobuf::RepeatedPtrField< ::QueryMembersAck_GroupMembers >*
      mutable_members();
  const ::google::protobuf::RepeatedPtrField< ::QueryMembersAck_GroupMembers >&
      members() const;

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:QueryMembersAck)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::QueryMembersAck_GroupMembers > members_;
  ::google::protobuf::int32 result_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JoinGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:JoinGroup) */ {
 public:
  JoinGroup();
  virtual ~JoinGroup();

  JoinGroup(const JoinGroup& from);

  inline JoinGroup& operator=(const JoinGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinGroup(JoinGroup&& from) noexcept
    : JoinGroup() {
    *this = ::std::move(from);
  }

  inline JoinGroup& operator=(JoinGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinGroup& default_instance();

  static inline const JoinGroup* internal_default_instance() {
    return reinterpret_cast<const JoinGroup*>(
               &_JoinGroup_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(JoinGroup* other);
  friend void swap(JoinGroup& a, JoinGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinGroup* New() const PROTOBUF_FINAL { return New(NULL); }

  JoinGroup* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JoinGroup& from);
  void MergeFrom(const JoinGroup& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JoinGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gid = 1;
  bool has_gid() const;
  void clear_gid();
  static const int kGidFieldNumber = 1;
  ::google::protobuf::uint32 gid() const;
  void set_gid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:JoinGroup)
 private:
  void set_has_gid();
  void clear_has_gid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 gid_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JoinGroupAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:JoinGroupAck) */ {
 public:
  JoinGroupAck();
  virtual ~JoinGroupAck();

  JoinGroupAck(const JoinGroupAck& from);

  inline JoinGroupAck& operator=(const JoinGroupAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinGroupAck(JoinGroupAck&& from) noexcept
    : JoinGroupAck() {
    *this = ::std::move(from);
  }

  inline JoinGroupAck& operator=(JoinGroupAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinGroupAck& default_instance();

  static inline const JoinGroupAck* internal_default_instance() {
    return reinterpret_cast<const JoinGroupAck*>(
               &_JoinGroupAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(JoinGroupAck* other);
  friend void swap(JoinGroupAck& a, JoinGroupAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinGroupAck* New() const PROTOBUF_FINAL { return New(NULL); }

  JoinGroupAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JoinGroupAck& from);
  void MergeFrom(const JoinGroupAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JoinGroupAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // optional uint32 gid = 2;
  bool has_gid() const;
  void clear_gid();
  static const int kGidFieldNumber = 2;
  ::google::protobuf::uint32 gid() const;
  void set_gid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:JoinGroupAck)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_gid();
  void clear_has_gid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::uint32 gid_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LeaveGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LeaveGroup) */ {
 public:
  LeaveGroup();
  virtual ~LeaveGroup();

  LeaveGroup(const LeaveGroup& from);

  inline LeaveGroup& operator=(const LeaveGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LeaveGroup(LeaveGroup&& from) noexcept
    : LeaveGroup() {
    *this = ::std::move(from);
  }

  inline LeaveGroup& operator=(LeaveGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveGroup& default_instance();

  static inline const LeaveGroup* internal_default_instance() {
    return reinterpret_cast<const LeaveGroup*>(
               &_LeaveGroup_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(LeaveGroup* other);
  friend void swap(LeaveGroup& a, LeaveGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LeaveGroup* New() const PROTOBUF_FINAL { return New(NULL); }

  LeaveGroup* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LeaveGroup& from);
  void MergeFrom(const LeaveGroup& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LeaveGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 gid = 1;
  bool has_gid() const;
  void clear_gid();
  static const int kGidFieldNumber = 1;
  ::google::protobuf::uint32 gid() const;
  void set_gid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:LeaveGroup)
 private:
  void set_has_gid();
  void clear_has_gid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 gid_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LeaveGroupAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LeaveGroupAck) */ {
 public:
  LeaveGroupAck();
  virtual ~LeaveGroupAck();

  LeaveGroupAck(const LeaveGroupAck& from);

  inline LeaveGroupAck& operator=(const LeaveGroupAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LeaveGroupAck(LeaveGroupAck&& from) noexcept
    : LeaveGroupAck() {
    *this = ::std::move(from);
  }

  inline LeaveGroupAck& operator=(LeaveGroupAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveGroupAck& default_instance();

  static inline const LeaveGroupAck* internal_default_instance() {
    return reinterpret_cast<const LeaveGroupAck*>(
               &_LeaveGroupAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(LeaveGroupAck* other);
  friend void swap(LeaveGroupAck& a, LeaveGroupAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LeaveGroupAck* New() const PROTOBUF_FINAL { return New(NULL); }

  LeaveGroupAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LeaveGroupAck& from);
  void MergeFrom(const LeaveGroupAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LeaveGroupAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // optional uint32 gid = 2;
  bool has_gid() const;
  void clear_gid();
  static const int kGidFieldNumber = 2;
  ::google::protobuf::uint32 gid() const;
  void set_gid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:LeaveGroupAck)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_gid();
  void clear_has_gid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::uint32 gid_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestMic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RequestMic) */ {
 public:
  RequestMic();
  virtual ~RequestMic();

  RequestMic(const RequestMic& from);

  inline RequestMic& operator=(const RequestMic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestMic(RequestMic&& from) noexcept
    : RequestMic() {
    *this = ::std::move(from);
  }

  inline RequestMic& operator=(RequestMic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestMic& default_instance();

  static inline const RequestMic* internal_default_instance() {
    return reinterpret_cast<const RequestMic*>(
               &_RequestMic_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(RequestMic* other);
  friend void swap(RequestMic& a, RequestMic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestMic* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestMic* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestMic& from);
  void MergeFrom(const RequestMic& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestMic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 gid = 1;
  bool has_gid() const;
  void clear_gid();
  static const int kGidFieldNumber = 1;
  ::google::protobuf::uint32 gid() const;
  void set_gid(::google::protobuf::uint32 value);

  // optional uint32 uid = 2;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 2;
  ::google::protobuf::uint32 uid() const;
  void set_uid(::google::protobuf::uint32 value);

  // optional uint32 payload = 3;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 3;
  ::google::protobuf::uint32 payload() const;
  void set_payload(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RequestMic)
 private:
  void set_has_gid();
  void clear_has_gid();
  void set_has_uid();
  void clear_has_uid();
  void set_has_payload();
  void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 gid_;
  ::google::protobuf::uint32 uid_;
  ::google::protobuf::uint32 payload_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestMicAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RequestMicAck) */ {
 public:
  RequestMicAck();
  virtual ~RequestMicAck();

  RequestMicAck(const RequestMicAck& from);

  inline RequestMicAck& operator=(const RequestMicAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestMicAck(RequestMicAck&& from) noexcept
    : RequestMicAck() {
    *this = ::std::move(from);
  }

  inline RequestMicAck& operator=(RequestMicAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestMicAck& default_instance();

  static inline const RequestMicAck* internal_default_instance() {
    return reinterpret_cast<const RequestMicAck*>(
               &_RequestMicAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(RequestMicAck* other);
  friend void swap(RequestMicAck& a, RequestMicAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestMicAck* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestMicAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestMicAck& from);
  void MergeFrom(const RequestMicAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestMicAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // optional uint32 cookie = 2;
  bool has_cookie() const;
  void clear_cookie();
  static const int kCookieFieldNumber = 2;
  ::google::protobuf::uint32 cookie() const;
  void set_cookie(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:RequestMicAck)
 private:
  void set_has_result();
  void clear_has_result();
  void set_has_cookie();
  void clear_has_cookie();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::uint32 cookie_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReleaseMic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ReleaseMic) */ {
 public:
  ReleaseMic();
  virtual ~ReleaseMic();

  ReleaseMic(const ReleaseMic& from);

  inline ReleaseMic& operator=(const ReleaseMic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReleaseMic(ReleaseMic&& from) noexcept
    : ReleaseMic() {
    *this = ::std::move(from);
  }

  inline ReleaseMic& operator=(ReleaseMic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReleaseMic& default_instance();

  static inline const ReleaseMic* internal_default_instance() {
    return reinterpret_cast<const ReleaseMic*>(
               &_ReleaseMic_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(ReleaseMic* other);
  friend void swap(ReleaseMic& a, ReleaseMic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReleaseMic* New() const PROTOBUF_FINAL { return New(NULL); }

  ReleaseMic* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReleaseMic& from);
  void MergeFrom(const ReleaseMic& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReleaseMic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 gid = 1;
  bool has_gid() const;
  void clear_gid();
  static const int kGidFieldNumber = 1;
  ::google::protobuf::uint32 gid() const;
  void set_gid(::google::protobuf::uint32 value);

  // optional uint32 uid = 2;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 2;
  ::google::protobuf::uint32 uid() const;
  void set_uid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ReleaseMic)
 private:
  void set_has_gid();
  void clear_has_gid();
  void set_has_uid();
  void clear_has_uid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 gid_;
  ::google::protobuf::uint32 uid_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReleaseMicAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ReleaseMicAck) */ {
 public:
  ReleaseMicAck();
  virtual ~ReleaseMicAck();

  ReleaseMicAck(const ReleaseMicAck& from);

  inline ReleaseMicAck& operator=(const ReleaseMicAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReleaseMicAck(ReleaseMicAck&& from) noexcept
    : ReleaseMicAck() {
    *this = ::std::move(from);
  }

  inline ReleaseMicAck& operator=(ReleaseMicAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReleaseMicAck& default_instance();

  static inline const ReleaseMicAck* internal_default_instance() {
    return reinterpret_cast<const ReleaseMicAck*>(
               &_ReleaseMicAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(ReleaseMicAck* other);
  friend void swap(ReleaseMicAck& a, ReleaseMicAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReleaseMicAck* New() const PROTOBUF_FINAL { return New(NULL); }

  ReleaseMicAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReleaseMicAck& from);
  void MergeFrom(const ReleaseMicAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReleaseMicAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ReleaseMicAck)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 result_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Call : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Call) */ {
 public:
  Call();
  virtual ~Call();

  Call(const Call& from);

  inline Call& operator=(const Call& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Call(Call&& from) noexcept
    : Call() {
    *this = ::std::move(from);
  }

  inline Call& operator=(Call&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call& default_instance();

  static inline const Call* internal_default_instance() {
    return reinterpret_cast<const Call*>(
               &_Call_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(Call* other);
  friend void swap(Call& a, Call& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Call* New() const PROTOBUF_FINAL { return New(NULL); }

  Call* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Call& from);
  void MergeFrom(const Call& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Call* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 uid = 1;
  int uid_size() const;
  void clear_uid();
  static const int kUidFieldNumber = 1;
  ::google::protobuf::uint32 uid(int index) const;
  void set_uid(int index, ::google::protobuf::uint32 value);
  void add_uid(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      uid() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_uid();

  // @@protoc_insertion_point(class_scope:Call)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > uid_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CallAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CallAck) */ {
 public:
  CallAck();
  virtual ~CallAck();

  CallAck(const CallAck& from);

  inline CallAck& operator=(const CallAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CallAck(CallAck&& from) noexcept
    : CallAck() {
    *this = ::std::move(from);
  }

  inline CallAck& operator=(CallAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CallAck& default_instance();

  static inline const CallAck* internal_default_instance() {
    return reinterpret_cast<const CallAck*>(
               &_CallAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(CallAck* other);
  friend void swap(CallAck& a, CallAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CallAck* New() const PROTOBUF_FINAL { return New(NULL); }

  CallAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CallAck& from);
  void MergeFrom(const CallAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CallAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 uid = 2;
  int uid_size() const;
  void clear_uid();
  static const int kUidFieldNumber = 2;
  ::google::protobuf::uint32 uid(int index) const;
  void set_uid(int index, ::google::protobuf::uint32 value);
  void add_uid(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      uid() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_uid();

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CallAck)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > uid_;
  ::google::protobuf::int32 result_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TempCallArrived : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TempCallArrived) */ {
 public:
  TempCallArrived();
  virtual ~TempCallArrived();

  TempCallArrived(const TempCallArrived& from);

  inline TempCallArrived& operator=(const TempCallArrived& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TempCallArrived(TempCallArrived&& from) noexcept
    : TempCallArrived() {
    *this = ::std::move(from);
  }

  inline TempCallArrived& operator=(TempCallArrived&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TempCallArrived& default_instance();

  static inline const TempCallArrived* internal_default_instance() {
    return reinterpret_cast<const TempCallArrived*>(
               &_TempCallArrived_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(TempCallArrived* other);
  friend void swap(TempCallArrived& a, TempCallArrived& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TempCallArrived* New() const PROTOBUF_FINAL { return New(NULL); }

  TempCallArrived* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TempCallArrived& from);
  void MergeFrom(const TempCallArrived& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TempCallArrived* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string call_name = 1;
  bool has_call_name() const;
  void clear_call_name();
  static const int kCallNameFieldNumber = 1;
  const ::std::string& call_name() const;
  void set_call_name(const ::std::string& value);
  #if LANG_CXX11
  void set_call_name(::std::string&& value);
  #endif
  void set_call_name(const char* value);
  void set_call_name(const char* value, size_t size);
  ::std::string* mutable_call_name();
  ::std::string* release_call_name();
  void set_allocated_call_name(::std::string* call_name);

  // @@protoc_insertion_point(class_scope:TempCallArrived)
 private:
  void set_has_call_name();
  void clear_has_call_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr call_name_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TempCallStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TempCallStatus) */ {
 public:
  TempCallStatus();
  virtual ~TempCallStatus();

  TempCallStatus(const TempCallStatus& from);

  inline TempCallStatus& operator=(const TempCallStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TempCallStatus(TempCallStatus&& from) noexcept
    : TempCallStatus() {
    *this = ::std::move(from);
  }

  inline TempCallStatus& operator=(TempCallStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TempCallStatus& default_instance();

  static inline const TempCallStatus* internal_default_instance() {
    return reinterpret_cast<const TempCallStatus*>(
               &_TempCallStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(TempCallStatus* other);
  friend void swap(TempCallStatus& a, TempCallStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TempCallStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  TempCallStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TempCallStatus& from);
  void MergeFrom(const TempCallStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TempCallStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 call_status = 1;
  bool has_call_status() const;
  void clear_call_status();
  static const int kCallStatusFieldNumber = 1;
  ::google::protobuf::uint32 call_status() const;
  void set_call_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TempCallStatus)
 private:
  void set_has_call_status();
  void clear_has_call_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 call_status_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Logout : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Logout) */ {
 public:
  Logout();
  virtual ~Logout();

  Logout(const Logout& from);

  inline Logout& operator=(const Logout& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Logout(Logout&& from) noexcept
    : Logout() {
    *this = ::std::move(from);
  }

  inline Logout& operator=(Logout&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Logout& default_instance();

  static inline const Logout* internal_default_instance() {
    return reinterpret_cast<const Logout*>(
               &_Logout_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(Logout* other);
  friend void swap(Logout& a, Logout& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Logout* New() const PROTOBUF_FINAL { return New(NULL); }

  Logout* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Logout& from);
  void MergeFrom(const Logout& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Logout* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Logout)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogoutAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LogoutAck) */ {
 public:
  LogoutAck();
  virtual ~LogoutAck();

  LogoutAck(const LogoutAck& from);

  inline LogoutAck& operator=(const LogoutAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogoutAck(LogoutAck&& from) noexcept
    : LogoutAck() {
    *this = ::std::move(from);
  }

  inline LogoutAck& operator=(LogoutAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutAck& default_instance();

  static inline const LogoutAck* internal_default_instance() {
    return reinterpret_cast<const LogoutAck*>(
               &_LogoutAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(LogoutAck* other);
  friend void swap(LogoutAck& a, LogoutAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogoutAck* New() const PROTOBUF_FINAL { return New(NULL); }

  LogoutAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LogoutAck& from);
  void MergeFrom(const LogoutAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LogoutAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LogoutAck)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 result_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReportLocation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ReportLocation) */ {
 public:
  ReportLocation();
  virtual ~ReportLocation();

  ReportLocation(const ReportLocation& from);

  inline ReportLocation& operator=(const ReportLocation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReportLocation(ReportLocation&& from) noexcept
    : ReportLocation() {
    *this = ::std::move(from);
  }

  inline ReportLocation& operator=(ReportLocation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportLocation& default_instance();

  static inline const ReportLocation* internal_default_instance() {
    return reinterpret_cast<const ReportLocation*>(
               &_ReportLocation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(ReportLocation* other);
  friend void swap(ReportLocation& a, ReportLocation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReportLocation* New() const PROTOBUF_FINAL { return New(NULL); }

  ReportLocation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReportLocation& from);
  void MergeFrom(const ReportLocation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReportLocation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double longitude = 1;
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 1;
  double longitude() const;
  void set_longitude(double value);

  // required double latitude = 2;
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  double latitude() const;
  void set_latitude(double value);

  // @@protoc_insertion_point(class_scope:ReportLocation)
 private:
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_latitude();
  void clear_has_latitude();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double longitude_;
  double latitude_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReportLocationAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ReportLocationAck) */ {
 public:
  ReportLocationAck();
  virtual ~ReportLocationAck();

  ReportLocationAck(const ReportLocationAck& from);

  inline ReportLocationAck& operator=(const ReportLocationAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReportLocationAck(ReportLocationAck&& from) noexcept
    : ReportLocationAck() {
    *this = ::std::move(from);
  }

  inline ReportLocationAck& operator=(ReportLocationAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportLocationAck& default_instance();

  static inline const ReportLocationAck* internal_default_instance() {
    return reinterpret_cast<const ReportLocationAck*>(
               &_ReportLocationAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(ReportLocationAck* other);
  friend void swap(ReportLocationAck& a, ReportLocationAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReportLocationAck* New() const PROTOBUF_FINAL { return New(NULL); }

  ReportLocationAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReportLocationAck& from);
  void MergeFrom(const ReportLocationAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReportLocationAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::google::protobuf::int32 result() const;
  void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ReportLocationAck)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 result_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ping : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Ping) */ {
 public:
  Ping();
  virtual ~Ping();

  Ping(const Ping& from);

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ping(Ping&& from) noexcept
    : Ping() {
    *this = ::std::move(from);
  }

  inline Ping& operator=(Ping&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ping& default_instance();

  static inline const Ping* internal_default_instance() {
    return reinterpret_cast<const Ping*>(
               &_Ping_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(Ping* other);
  friend void swap(Ping& a, Ping& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ping* New() const PROTOBUF_FINAL { return New(NULL); }

  Ping* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Ping* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Ping)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 timestamp_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PingAck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PingAck) */ {
 public:
  PingAck();
  virtual ~PingAck();

  PingAck(const PingAck& from);

  inline PingAck& operator=(const PingAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PingAck(PingAck&& from) noexcept
    : PingAck() {
    *this = ::std::move(from);
  }

  inline PingAck& operator=(PingAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PingAck& default_instance();

  static inline const PingAck* internal_default_instance() {
    return reinterpret_cast<const PingAck*>(
               &_PingAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(PingAck* other);
  friend void swap(PingAck& a, PingAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PingAck* New() const PROTOBUF_FINAL { return New(NULL); }

  PingAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PingAck& from);
  void MergeFrom(const PingAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PingAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:PingAck)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 timestamp_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LostMic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LostMic) */ {
 public:
  LostMic();
  virtual ~LostMic();

  LostMic(const LostMic& from);

  inline LostMic& operator=(const LostMic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LostMic(LostMic&& from) noexcept
    : LostMic() {
    *this = ::std::move(from);
  }

  inline LostMic& operator=(LostMic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LostMic& default_instance();

  static inline const LostMic* internal_default_instance() {
    return reinterpret_cast<const LostMic*>(
               &_LostMic_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(LostMic* other);
  friend void swap(LostMic& a, LostMic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LostMic* New() const PROTOBUF_FINAL { return New(NULL); }

  LostMic* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LostMic& from);
  void MergeFrom(const LostMic& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LostMic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string reason = 2;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 2;
  const ::std::string& reason() const;
  void set_reason(const ::std::string& value);
  #if LANG_CXX11
  void set_reason(::std::string&& value);
  #endif
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  ::std::string* mutable_reason();
  ::std::string* release_reason();
  void set_allocated_reason(::std::string* reason);

  // required uint32 gid = 1;
  bool has_gid() const;
  void clear_gid();
  static const int kGidFieldNumber = 1;
  ::google::protobuf::uint32 gid() const;
  void set_gid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:LostMic)
 private:
  void set_has_gid();
  void clear_has_gid();
  void set_has_reason();
  void clear_has_reason();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr reason_;
  ::google::protobuf::uint32 gid_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Kickout : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Kickout) */ {
 public:
  Kickout();
  virtual ~Kickout();

  Kickout(const Kickout& from);

  inline Kickout& operator=(const Kickout& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Kickout(Kickout&& from) noexcept
    : Kickout() {
    *this = ::std::move(from);
  }

  inline Kickout& operator=(Kickout&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Kickout& default_instance();

  static inline const Kickout* internal_default_instance() {
    return reinterpret_cast<const Kickout*>(
               &_Kickout_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(Kickout* other);
  friend void swap(Kickout& a, Kickout& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Kickout* New() const PROTOBUF_FINAL { return New(NULL); }

  Kickout* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Kickout& from);
  void MergeFrom(const Kickout& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Kickout* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string reason = 1;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 1;
  const ::std::string& reason() const;
  void set_reason(const ::std::string& value);
  #if LANG_CXX11
  void set_reason(::std::string&& value);
  #endif
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  ::std::string* mutable_reason();
  ::std::string* release_reason();
  void set_allocated_reason(::std::string* reason);

  // @@protoc_insertion_point(class_scope:Kickout)
 private:
  void set_has_reason();
  void clear_has_reason();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr reason_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Reconfigured : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Reconfigured) */ {
 public:
  Reconfigured();
  virtual ~Reconfigured();

  Reconfigured(const Reconfigured& from);

  inline Reconfigured& operator=(const Reconfigured& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Reconfigured(Reconfigured&& from) noexcept
    : Reconfigured() {
    *this = ::std::move(from);
  }

  inline Reconfigured& operator=(Reconfigured&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Reconfigured& default_instance();

  static inline const Reconfigured* internal_default_instance() {
    return reinterpret_cast<const Reconfigured*>(
               &_Reconfigured_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(Reconfigured* other);
  friend void swap(Reconfigured& a, Reconfigured& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Reconfigured* New() const PROTOBUF_FINAL { return New(NULL); }

  Reconfigured* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Reconfigured& from);
  void MergeFrom(const Reconfigured& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Reconfigured* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Configure conf = 1;
  bool has_conf() const;
  void clear_conf();
  static const int kConfFieldNumber = 1;
  const ::Configure& conf() const;
  ::Configure* mutable_conf();
  ::Configure* release_conf();
  void set_allocated_conf(::Configure* conf);

  // @@protoc_insertion_point(class_scope:Reconfigured)
 private:
  void set_has_conf();
  void clear_has_conf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::Configure* conf_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CurrentGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CurrentGroup) */ {
 public:
  CurrentGroup();
  virtual ~CurrentGroup();

  CurrentGroup(const CurrentGroup& from);

  inline CurrentGroup& operator=(const CurrentGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CurrentGroup(CurrentGroup&& from) noexcept
    : CurrentGroup() {
    *this = ::std::move(from);
  }

  inline CurrentGroup& operator=(CurrentGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CurrentGroup& default_instance();

  static inline const CurrentGroup* internal_default_instance() {
    return reinterpret_cast<const CurrentGroup*>(
               &_CurrentGroup_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(CurrentGroup* other);
  friend void swap(CurrentGroup& a, CurrentGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CurrentGroup* New() const PROTOBUF_FINAL { return New(NULL); }

  CurrentGroup* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CurrentGroup& from);
  void MergeFrom(const CurrentGroup& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CurrentGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string reason = 2;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 2;
  const ::std::string& reason() const;
  void set_reason(const ::std::string& value);
  #if LANG_CXX11
  void set_reason(::std::string&& value);
  #endif
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  ::std::string* mutable_reason();
  ::std::string* release_reason();
  void set_allocated_reason(::std::string* reason);

  // required string gname = 3;
  bool has_gname() const;
  void clear_gname();
  static const int kGnameFieldNumber = 3;
  const ::std::string& gname() const;
  void set_gname(const ::std::string& value);
  #if LANG_CXX11
  void set_gname(::std::string&& value);
  #endif
  void set_gname(const char* value);
  void set_gname(const char* value, size_t size);
  ::std::string* mutable_gname();
  ::std::string* release_gname();
  void set_allocated_gname(::std::string* gname);

  // required uint32 gid = 1;
  bool has_gid() const;
  void clear_gid();
  static const int kGidFieldNumber = 1;
  ::google::protobuf::uint32 gid() const;
  void set_gid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CurrentGroup)
 private:
  void set_has_gid();
  void clear_has_gid();
  void set_has_reason();
  void clear_has_reason();
  void set_has_gname();
  void clear_has_gname();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr reason_;
  ::google::protobuf::internal::ArenaStringPtr gname_;
  ::google::protobuf::uint32 gid_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GroupListChanged : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GroupListChanged) */ {
 public:
  GroupListChanged();
  virtual ~GroupListChanged();

  GroupListChanged(const GroupListChanged& from);

  inline GroupListChanged& operator=(const GroupListChanged& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GroupListChanged(GroupListChanged&& from) noexcept
    : GroupListChanged() {
    *this = ::std::move(from);
  }

  inline GroupListChanged& operator=(GroupListChanged&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupListChanged& default_instance();

  static inline const GroupListChanged* internal_default_instance() {
    return reinterpret_cast<const GroupListChanged*>(
               &_GroupListChanged_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(GroupListChanged* other);
  friend void swap(GroupListChanged& a, GroupListChanged& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GroupListChanged* New() const PROTOBUF_FINAL { return New(NULL); }

  GroupListChanged* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GroupListChanged& from);
  void MergeFrom(const GroupListChanged& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GroupListChanged* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Group update_groups = 1;
  int update_groups_size() const;
  void clear_update_groups();
  static const int kUpdateGroupsFieldNumber = 1;
  const ::Group& update_groups(int index) const;
  ::Group* mutable_update_groups(int index);
  ::Group* add_update_groups();
  ::google::protobuf::RepeatedPtrField< ::Group >*
      mutable_update_groups();
  const ::google::protobuf::RepeatedPtrField< ::Group >&
      update_groups() const;

  // repeated uint32 rm_groups = 2;
  int rm_groups_size() const;
  void clear_rm_groups();
  static const int kRmGroupsFieldNumber = 2;
  ::google::protobuf::uint32 rm_groups(int index) const;
  void set_rm_groups(int index, ::google::protobuf::uint32 value);
  void add_rm_groups(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      rm_groups() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_rm_groups();

  // @@protoc_insertion_point(class_scope:GroupListChanged)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Group > update_groups_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > rm_groups_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MemberGetMic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MemberGetMic) */ {
 public:
  MemberGetMic();
  virtual ~MemberGetMic();

  MemberGetMic(const MemberGetMic& from);

  inline MemberGetMic& operator=(const MemberGetMic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MemberGetMic(MemberGetMic&& from) noexcept
    : MemberGetMic() {
    *this = ::std::move(from);
  }

  inline MemberGetMic& operator=(MemberGetMic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemberGetMic& default_instance();

  static inline const MemberGetMic* internal_default_instance() {
    return reinterpret_cast<const MemberGetMic*>(
               &_MemberGetMic_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(MemberGetMic* other);
  friend void swap(MemberGetMic& a, MemberGetMic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MemberGetMic* New() const PROTOBUF_FINAL { return New(NULL); }

  MemberGetMic* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MemberGetMic& from);
  void MergeFrom(const MemberGetMic& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MemberGetMic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required uint32 gid = 1;
  bool has_gid() const;
  void clear_gid();
  static const int kGidFieldNumber = 1;
  ::google::protobuf::uint32 gid() const;
  void set_gid(::google::protobuf::uint32 value);

  // required uint32 uid = 2;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 2;
  ::google::protobuf::uint32 uid() const;
  void set_uid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MemberGetMic)
 private:
  void set_has_gid();
  void clear_has_gid();
  void set_has_uid();
  void clear_has_uid();
  void set_has_name();
  void clear_has_name();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 gid_;
  ::google::protobuf::uint32 uid_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MemberLostMic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MemberLostMic) */ {
 public:
  MemberLostMic();
  virtual ~MemberLostMic();

  MemberLostMic(const MemberLostMic& from);

  inline MemberLostMic& operator=(const MemberLostMic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MemberLostMic(MemberLostMic&& from) noexcept
    : MemberLostMic() {
    *this = ::std::move(from);
  }

  inline MemberLostMic& operator=(MemberLostMic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemberLostMic& default_instance();

  static inline const MemberLostMic* internal_default_instance() {
    return reinterpret_cast<const MemberLostMic*>(
               &_MemberLostMic_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(MemberLostMic* other);
  friend void swap(MemberLostMic& a, MemberLostMic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MemberLostMic* New() const PROTOBUF_FINAL { return New(NULL); }

  MemberLostMic* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MemberLostMic& from);
  void MergeFrom(const MemberLostMic& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MemberLostMic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gid = 1;
  bool has_gid() const;
  void clear_gid();
  static const int kGidFieldNumber = 1;
  ::google::protobuf::uint32 gid() const;
  void set_gid(::google::protobuf::uint32 value);

  // required uint32 uid = 2;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 2;
  ::google::protobuf::uint32 uid() const;
  void set_uid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MemberLostMic)
 private:
  void set_has_gid();
  void clear_has_gid();
  void set_has_uid();
  void clear_has_uid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 gid_;
  ::google::protobuf::uint32 uid_;
  friend struct protobuf_ptt_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// User

// required uint32 uid = 1;
inline bool User::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void User::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void User::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void User::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 User::uid() const {
  // @@protoc_insertion_point(field_get:User.uid)
  return uid_;
}
inline void User::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:User.uid)
}

// required string name = 2;
inline bool User::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& User::name() const {
  // @@protoc_insertion_point(field_get:User.name)
  return name_.GetNoArena();
}
inline void User::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:User.name)
}
#if LANG_CXX11
inline void User::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:User.name)
}
#endif
inline void User::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:User.name)
}
inline void User::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:User.name)
}
inline ::std::string* User::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:User.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_name() {
  // @@protoc_insertion_point(field_release:User.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:User.name)
}

// optional bool online = 3;
inline bool User::has_online() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void User::set_has_online() {
  _has_bits_[0] |= 0x00000004u;
}
inline void User::clear_has_online() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void User::clear_online() {
  online_ = false;
  clear_has_online();
}
inline bool User::online() const {
  // @@protoc_insertion_point(field_get:User.online)
  return online_;
}
inline void User::set_online(bool value) {
  set_has_online();
  online_ = value;
  // @@protoc_insertion_point(field_set:User.online)
}

// optional uint32 usr_attri = 4;
inline bool User::has_usr_attri() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void User::set_has_usr_attri() {
  _has_bits_[0] |= 0x00000008u;
}
inline void User::clear_has_usr_attri() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void User::clear_usr_attri() {
  usr_attri_ = 0u;
  clear_has_usr_attri();
}
inline ::google::protobuf::uint32 User::usr_attri() const {
  // @@protoc_insertion_point(field_get:User.usr_attri)
  return usr_attri_;
}
inline void User::set_usr_attri(::google::protobuf::uint32 value) {
  set_has_usr_attri();
  usr_attri_ = value;
  // @@protoc_insertion_point(field_set:User.usr_attri)
}

// -------------------------------------------------------------------

// Group

// required uint32 gid = 1;
inline bool Group::has_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Group::set_has_gid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Group::clear_has_gid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Group::clear_gid() {
  gid_ = 0u;
  clear_has_gid();
}
inline ::google::protobuf::uint32 Group::gid() const {
  // @@protoc_insertion_point(field_get:Group.gid)
  return gid_;
}
inline void Group::set_gid(::google::protobuf::uint32 value) {
  set_has_gid();
  gid_ = value;
  // @@protoc_insertion_point(field_set:Group.gid)
}

// required string name = 2;
inline bool Group::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Group::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Group::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Group::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Group::name() const {
  // @@protoc_insertion_point(field_get:Group.name)
  return name_.GetNoArena();
}
inline void Group::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Group.name)
}
#if LANG_CXX11
inline void Group::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Group.name)
}
#endif
inline void Group::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Group.name)
}
inline void Group::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Group.name)
}
inline ::std::string* Group::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:Group.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Group::release_name() {
  // @@protoc_insertion_point(field_release:Group.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Group::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Group.name)
}

// required uint32 n_members = 3;
inline bool Group::has_n_members() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Group::set_has_n_members() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Group::clear_has_n_members() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Group::clear_n_members() {
  n_members_ = 0u;
  clear_has_n_members();
}
inline ::google::protobuf::uint32 Group::n_members() const {
  // @@protoc_insertion_point(field_get:Group.n_members)
  return n_members_;
}
inline void Group::set_n_members(::google::protobuf::uint32 value) {
  set_has_n_members();
  n_members_ = value;
  // @@protoc_insertion_point(field_set:Group.n_members)
}

// optional .Group.GroupType type = 4 [default = STATIC];
inline bool Group::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Group::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Group::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Group::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Group_GroupType Group::type() const {
  // @@protoc_insertion_point(field_get:Group.type)
  return static_cast< ::Group_GroupType >(type_);
}
inline void Group::set_type(::Group_GroupType value) {
  assert(::Group_GroupType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:Group.type)
}

// -------------------------------------------------------------------

// Configure

// required uint32 default_group = 1;
inline bool Configure::has_default_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Configure::set_has_default_group() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Configure::clear_has_default_group() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Configure::clear_default_group() {
  default_group_ = 0u;
  clear_has_default_group();
}
inline ::google::protobuf::uint32 Configure::default_group() const {
  // @@protoc_insertion_point(field_get:Configure.default_group)
  return default_group_;
}
inline void Configure::set_default_group(::google::protobuf::uint32 value) {
  set_has_default_group();
  default_group_ = value;
  // @@protoc_insertion_point(field_set:Configure.default_group)
}

// optional uint32 loc_report_period = 2;
inline bool Configure::has_loc_report_period() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Configure::set_has_loc_report_period() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Configure::clear_has_loc_report_period() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Configure::clear_loc_report_period() {
  loc_report_period_ = 0u;
  clear_has_loc_report_period();
}
inline ::google::protobuf::uint32 Configure::loc_report_period() const {
  // @@protoc_insertion_point(field_get:Configure.loc_report_period)
  return loc_report_period_;
}
inline void Configure::set_loc_report_period(::google::protobuf::uint32 value) {
  set_has_loc_report_period();
  loc_report_period_ = value;
  // @@protoc_insertion_point(field_set:Configure.loc_report_period)
}

// optional bool audio_enabled = 3 [default = true];
inline bool Configure::has_audio_enabled() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Configure::set_has_audio_enabled() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Configure::clear_has_audio_enabled() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Configure::clear_audio_enabled() {
  audio_enabled_ = true;
  clear_has_audio_enabled();
}
inline bool Configure::audio_enabled() const {
  // @@protoc_insertion_point(field_get:Configure.audio_enabled)
  return audio_enabled_;
}
inline void Configure::set_audio_enabled(bool value) {
  set_has_audio_enabled();
  audio_enabled_ = value;
  // @@protoc_insertion_point(field_set:Configure.audio_enabled)
}

// optional uint32 cfg_ptt_timeout = 4;
inline bool Configure::has_cfg_ptt_timeout() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Configure::set_has_cfg_ptt_timeout() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Configure::clear_has_cfg_ptt_timeout() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Configure::clear_cfg_ptt_timeout() {
  cfg_ptt_timeout_ = 0u;
  clear_has_cfg_ptt_timeout();
}
inline ::google::protobuf::uint32 Configure::cfg_ptt_timeout() const {
  // @@protoc_insertion_point(field_get:Configure.cfg_ptt_timeout)
  return cfg_ptt_timeout_;
}
inline void Configure::set_cfg_ptt_timeout(::google::protobuf::uint32 value) {
  set_has_cfg_ptt_timeout();
  cfg_ptt_timeout_ = value;
  // @@protoc_insertion_point(field_set:Configure.cfg_ptt_timeout)
}

// optional uint32 heart_inter = 5;
inline bool Configure::has_heart_inter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Configure::set_has_heart_inter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Configure::clear_has_heart_inter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Configure::clear_heart_inter() {
  heart_inter_ = 0u;
  clear_has_heart_inter();
}
inline ::google::protobuf::uint32 Configure::heart_inter() const {
  // @@protoc_insertion_point(field_get:Configure.heart_inter)
  return heart_inter_;
}
inline void Configure::set_heart_inter(::google::protobuf::uint32 value) {
  set_has_heart_inter();
  heart_inter_ = value;
  // @@protoc_insertion_point(field_set:Configure.heart_inter)
}

// -------------------------------------------------------------------

// ServerInfo

// required string address = 1;
inline bool ServerInfo::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerInfo::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerInfo::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerInfo::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
inline const ::std::string& ServerInfo::address() const {
  // @@protoc_insertion_point(field_get:ServerInfo.address)
  return address_.GetNoArena();
}
inline void ServerInfo::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ServerInfo.address)
}
#if LANG_CXX11
inline void ServerInfo::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ServerInfo.address)
}
#endif
inline void ServerInfo::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ServerInfo.address)
}
inline void ServerInfo::set_address(const char* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ServerInfo.address)
}
inline ::std::string* ServerInfo::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:ServerInfo.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerInfo::release_address() {
  // @@protoc_insertion_point(field_release:ServerInfo.address)
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerInfo::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:ServerInfo.address)
}

// required uint32 port = 2;
inline bool ServerInfo::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerInfo::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerInfo::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 ServerInfo::port() const {
  // @@protoc_insertion_point(field_get:ServerInfo.port)
  return port_;
}
inline void ServerInfo::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:ServerInfo.port)
}

// -------------------------------------------------------------------

// Login

// required string account = 1;
inline bool Login::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Login::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Login::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Login::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_account();
}
inline const ::std::string& Login::account() const {
  // @@protoc_insertion_point(field_get:Login.account)
  return account_.GetNoArena();
}
inline void Login::set_account(const ::std::string& value) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Login.account)
}
#if LANG_CXX11
inline void Login::set_account(::std::string&& value) {
  set_has_account();
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Login.account)
}
#endif
inline void Login::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Login.account)
}
inline void Login::set_account(const char* value, size_t size) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Login.account)
}
inline ::std::string* Login::mutable_account() {
  set_has_account();
  // @@protoc_insertion_point(field_mutable:Login.account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_account() {
  // @@protoc_insertion_point(field_release:Login.account)
  clear_has_account();
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    set_has_account();
  } else {
    clear_has_account();
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:Login.account)
}

// optional string password = 2;
inline bool Login::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Login::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Login::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Login::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& Login::password() const {
  // @@protoc_insertion_point(field_get:Login.password)
  return password_.GetNoArena();
}
inline void Login::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Login.password)
}
#if LANG_CXX11
inline void Login::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Login.password)
}
#endif
inline void Login::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Login.password)
}
inline void Login::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Login.password)
}
inline ::std::string* Login::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:Login.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_password() {
  // @@protoc_insertion_point(field_release:Login.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:Login.password)
}

// optional int32 version = 3;
inline bool Login::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Login::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Login::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Login::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 Login::version() const {
  // @@protoc_insertion_point(field_get:Login.version)
  return version_;
}
inline void Login::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:Login.version)
}

// required string platform = 4;
inline bool Login::has_platform() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Login::set_has_platform() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Login::clear_has_platform() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Login::clear_platform() {
  platform_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_platform();
}
inline const ::std::string& Login::platform() const {
  // @@protoc_insertion_point(field_get:Login.platform)
  return platform_.GetNoArena();
}
inline void Login::set_platform(const ::std::string& value) {
  set_has_platform();
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Login.platform)
}
#if LANG_CXX11
inline void Login::set_platform(::std::string&& value) {
  set_has_platform();
  platform_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Login.platform)
}
#endif
inline void Login::set_platform(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_platform();
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Login.platform)
}
inline void Login::set_platform(const char* value, size_t size) {
  set_has_platform();
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Login.platform)
}
inline ::std::string* Login::mutable_platform() {
  set_has_platform();
  // @@protoc_insertion_point(field_mutable:Login.platform)
  return platform_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_platform() {
  // @@protoc_insertion_point(field_release:Login.platform)
  clear_has_platform();
  return platform_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_platform(::std::string* platform) {
  if (platform != NULL) {
    set_has_platform();
  } else {
    clear_has_platform();
  }
  platform_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), platform);
  // @@protoc_insertion_point(field_set_allocated:Login.platform)
}

// required string device = 5;
inline bool Login::has_device() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Login::set_has_device() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Login::clear_has_device() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Login::clear_device() {
  device_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device();
}
inline const ::std::string& Login::device() const {
  // @@protoc_insertion_point(field_get:Login.device)
  return device_.GetNoArena();
}
inline void Login::set_device(const ::std::string& value) {
  set_has_device();
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Login.device)
}
#if LANG_CXX11
inline void Login::set_device(::std::string&& value) {
  set_has_device();
  device_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Login.device)
}
#endif
inline void Login::set_device(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_device();
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Login.device)
}
inline void Login::set_device(const char* value, size_t size) {
  set_has_device();
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Login.device)
}
inline ::std::string* Login::mutable_device() {
  set_has_device();
  // @@protoc_insertion_point(field_mutable:Login.device)
  return device_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_device() {
  // @@protoc_insertion_point(field_release:Login.device)
  clear_has_device();
  return device_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_device(::std::string* device) {
  if (device != NULL) {
    set_has_device();
  } else {
    clear_has_device();
  }
  device_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device);
  // @@protoc_insertion_point(field_set_allocated:Login.device)
}

// optional string meid = 6;
inline bool Login::has_meid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Login::set_has_meid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Login::clear_has_meid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Login::clear_meid() {
  meid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_meid();
}
inline const ::std::string& Login::meid() const {
  // @@protoc_insertion_point(field_get:Login.meid)
  return meid_.GetNoArena();
}
inline void Login::set_meid(const ::std::string& value) {
  set_has_meid();
  meid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Login.meid)
}
#if LANG_CXX11
inline void Login::set_meid(::std::string&& value) {
  set_has_meid();
  meid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Login.meid)
}
#endif
inline void Login::set_meid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_meid();
  meid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Login.meid)
}
inline void Login::set_meid(const char* value, size_t size) {
  set_has_meid();
  meid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Login.meid)
}
inline ::std::string* Login::mutable_meid() {
  set_has_meid();
  // @@protoc_insertion_point(field_mutable:Login.meid)
  return meid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_meid() {
  // @@protoc_insertion_point(field_release:Login.meid)
  clear_has_meid();
  return meid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_meid(::std::string* meid) {
  if (meid != NULL) {
    set_has_meid();
  } else {
    clear_has_meid();
  }
  meid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), meid);
  // @@protoc_insertion_point(field_set_allocated:Login.meid)
}

// optional uint32 expect_payload = 7 [default = 101];
inline bool Login::has_expect_payload() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Login::set_has_expect_payload() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Login::clear_has_expect_payload() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Login::clear_expect_payload() {
  expect_payload_ = 101u;
  clear_has_expect_payload();
}
inline ::google::protobuf::uint32 Login::expect_payload() const {
  // @@protoc_insertion_point(field_get:Login.expect_payload)
  return expect_payload_;
}
inline void Login::set_expect_payload(::google::protobuf::uint32 value) {
  set_has_expect_payload();
  expect_payload_ = value;
  // @@protoc_insertion_point(field_set:Login.expect_payload)
}

// -------------------------------------------------------------------

// LoginAck

// required int32 result = 1;
inline bool LoginAck::has_result() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginAck::set_has_result() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginAck::clear_has_result() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginAck::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 LoginAck::result() const {
  // @@protoc_insertion_point(field_get:LoginAck.result)
  return result_;
}
inline void LoginAck::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:LoginAck.result)
}

// required .User usr = 2;
inline bool LoginAck::has_usr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginAck::set_has_usr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginAck::clear_has_usr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginAck::clear_usr() {
  if (usr_ != NULL) usr_->::User::Clear();
  clear_has_usr();
}
inline const ::User& LoginAck::usr() const {
  const ::User* p = usr_;
  // @@protoc_insertion_point(field_get:LoginAck.usr)
  return p != NULL ? *p : *reinterpret_cast<const ::User*>(
      &::_User_default_instance_);
}
inline ::User* LoginAck::mutable_usr() {
  set_has_usr();
  if (usr_ == NULL) {
    usr_ = new ::User;
  }
  // @@protoc_insertion_point(field_mutable:LoginAck.usr)
  return usr_;
}
inline ::User* LoginAck::release_usr() {
  // @@protoc_insertion_point(field_release:LoginAck.usr)
  clear_has_usr();
  ::User* temp = usr_;
  usr_ = NULL;
  return temp;
}
inline void LoginAck::set_allocated_usr(::User* usr) {
  delete usr_;
  usr_ = usr;
  if (usr) {
    set_has_usr();
  } else {
    clear_has_usr();
  }
  // @@protoc_insertion_point(field_set_allocated:LoginAck.usr)
}

// required .Configure conf = 3;
inline bool LoginAck::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginAck::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginAck::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginAck::clear_conf() {
  if (conf_ != NULL) conf_->::Configure::Clear();
  clear_has_conf();
}
inline const ::Configure& LoginAck::conf() const {
  const ::Configure* p = conf_;
  // @@protoc_insertion_point(field_get:LoginAck.conf)
  return p != NULL ? *p : *reinterpret_cast<const ::Configure*>(
      &::_Configure_default_instance_);
}
inline ::Configure* LoginAck::mutable_conf() {
  set_has_conf();
  if (conf_ == NULL) {
    conf_ = new ::Configure;
  }
  // @@protoc_insertion_point(field_mutable:LoginAck.conf)
  return conf_;
}
inline ::Configure* LoginAck::release_conf() {
  // @@protoc_insertion_point(field_release:LoginAck.conf)
  clear_has_conf();
  ::Configure* temp = conf_;
  conf_ = NULL;
  return temp;
}
inline void LoginAck::set_allocated_conf(::Configure* conf) {
  delete conf_;
  conf_ = conf;
  if (conf) {
    set_has_conf();
  } else {
    clear_has_conf();
  }
  // @@protoc_insertion_point(field_set_allocated:LoginAck.conf)
}

// optional .ServerInfo tcp_server = 4;
inline bool LoginAck::has_tcp_server() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginAck::set_has_tcp_server() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginAck::clear_has_tcp_server() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginAck::clear_tcp_server() {
  if (tcp_server_ != NULL) tcp_server_->::ServerInfo::Clear();
  clear_has_tcp_server();
}
inline const ::ServerInfo& LoginAck::tcp_server() const {
  const ::ServerInfo* p = tcp_server_;
  // @@protoc_insertion_point(field_get:LoginAck.tcp_server)
  return p != NULL ? *p : *reinterpret_cast<const ::ServerInfo*>(
      &::_ServerInfo_default_instance_);
}
inline ::ServerInfo* LoginAck::mutable_tcp_server() {
  set_has_tcp_server();
  if (tcp_server_ == NULL) {
    tcp_server_ = new ::ServerInfo;
  }
  // @@protoc_insertion_point(field_mutable:LoginAck.tcp_server)
  return tcp_server_;
}
inline ::ServerInfo* LoginAck::release_tcp_server() {
  // @@protoc_insertion_point(field_release:LoginAck.tcp_server)
  clear_has_tcp_server();
  ::ServerInfo* temp = tcp_server_;
  tcp_server_ = NULL;
  return temp;
}
inline void LoginAck::set_allocated_tcp_server(::ServerInfo* tcp_server) {
  delete tcp_server_;
  tcp_server_ = tcp_server;
  if (tcp_server) {
    set_has_tcp_server();
  } else {
    clear_has_tcp_server();
  }
  // @@protoc_insertion_point(field_set_allocated:LoginAck.tcp_server)
}

// optional .ServerInfo udp_server = 5;
inline bool LoginAck::has_udp_server() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginAck::set_has_udp_server() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginAck::clear_has_udp_server() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginAck::clear_udp_server() {
  if (udp_server_ != NULL) udp_server_->::ServerInfo::Clear();
  clear_has_udp_server();
}
inline const ::ServerInfo& LoginAck::udp_server() const {
  const ::ServerInfo* p = udp_server_;
  // @@protoc_insertion_point(field_get:LoginAck.udp_server)
  return p != NULL ? *p : *reinterpret_cast<const ::ServerInfo*>(
      &::_ServerInfo_default_instance_);
}
inline ::ServerInfo* LoginAck::mutable_udp_server() {
  set_has_udp_server();
  if (udp_server_ == NULL) {
    udp_server_ = new ::ServerInfo;
  }
  // @@protoc_insertion_point(field_mutable:LoginAck.udp_server)
  return udp_server_;
}
inline ::ServerInfo* LoginAck::release_udp_server() {
  // @@protoc_insertion_point(field_release:LoginAck.udp_server)
  clear_has_udp_server();
  ::ServerInfo* temp = udp_server_;
  udp_server_ = NULL;
  return temp;
}
inline void LoginAck::set_allocated_udp_server(::ServerInfo* udp_server) {
  delete udp_server_;
  udp_server_ = udp_server;
  if (udp_server) {
    set_has_udp_server();
  } else {
    clear_has_udp_server();
  }
  // @@protoc_insertion_point(field_set_allocated:LoginAck.udp_server)
}

// optional .ServerInfo update_server = 6;
inline bool LoginAck::has_update_server() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginAck::set_has_update_server() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginAck::clear_has_update_server() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginAck::clear_update_server() {
  if (update_server_ != NULL) update_server_->::ServerInfo::Clear();
  clear_has_update_server();
}
inline const ::ServerInfo& LoginAck::update_server() const {
  const ::ServerInfo* p = update_server_;
  // @@protoc_insertion_point(field_get:LoginAck.update_server)
  return p != NULL ? *p : *reinterpret_cast<const ::ServerInfo*>(
      &::_ServerInfo_default_instance_);
}
inline ::ServerInfo* LoginAck::mutable_update_server() {
  set_has_update_server();
  if (update_server_ == NULL) {
    update_server_ = new ::ServerInfo;
  }
  // @@protoc_insertion_point(field_mutable:LoginAck.update_server)
  return update_server_;
}
inline ::ServerInfo* LoginAck::release_update_server() {
  // @@protoc_insertion_point(field_release:LoginAck.update_server)
  clear_has_update_server();
  ::ServerInfo* temp = update_server_;
  update_server_ = NULL;
  return temp;
}
inline void LoginAck::set_allocated_update_server(::ServerInfo* update_server) {
  delete update_server_;
  update_server_ = update_server;
  if (update_server) {
    set_has_update_server();
  } else {
    clear_has_update_server();
  }
  // @@protoc_insertion_point(field_set_allocated:LoginAck.update_server)
}

// optional uint32 cookie = 7;
inline bool LoginAck::has_cookie() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginAck::set_has_cookie() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginAck::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginAck::clear_cookie() {
  cookie_ = 0u;
  clear_has_cookie();
}
inline ::google::protobuf::uint32 LoginAck::cookie() const {
  // @@protoc_insertion_point(field_get:LoginAck.cookie)
  return cookie_;
}
inline void LoginAck::set_cookie(::google::protobuf::uint32 value) {
  set_has_cookie();
  cookie_ = value;
  // @@protoc_insertion_point(field_set:LoginAck.cookie)
}

// -------------------------------------------------------------------

// QueryGroup

// required .QueryGroup.DetailLevel detail = 1 [default = GROUP_INFO];
inline bool QueryGroup::has_detail() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryGroup::set_has_detail() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryGroup::clear_has_detail() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryGroup::clear_detail() {
  detail_ = 1;
  clear_has_detail();
}
inline ::QueryGroup_DetailLevel QueryGroup::detail() const {
  // @@protoc_insertion_point(field_get:QueryGroup.detail)
  return static_cast< ::QueryGroup_DetailLevel >(detail_);
}
inline void QueryGroup::set_detail(::QueryGroup_DetailLevel value) {
  assert(::QueryGroup_DetailLevel_IsValid(value));
  set_has_detail();
  detail_ = value;
  // @@protoc_insertion_point(field_set:QueryGroup.detail)
}

// optional bool include_temp = 2 [default = false];
inline bool QueryGroup::has_include_temp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryGroup::set_has_include_temp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryGroup::clear_has_include_temp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryGroup::clear_include_temp() {
  include_temp_ = false;
  clear_has_include_temp();
}
inline bool QueryGroup::include_temp() const {
  // @@protoc_insertion_point(field_get:QueryGroup.include_temp)
  return include_temp_;
}
inline void QueryGroup::set_include_temp(bool value) {
  set_has_include_temp();
  include_temp_ = value;
  // @@protoc_insertion_point(field_set:QueryGroup.include_temp)
}

// -------------------------------------------------------------------

// QueryGroupAck

// required int32 result = 1;
inline bool QueryGroupAck::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryGroupAck::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryGroupAck::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryGroupAck::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 QueryGroupAck::result() const {
  // @@protoc_insertion_point(field_get:QueryGroupAck.result)
  return result_;
}
inline void QueryGroupAck::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:QueryGroupAck.result)
}

// repeated .Group groups = 2;
inline int QueryGroupAck::groups_size() const {
  return groups_.size();
}
inline void QueryGroupAck::clear_groups() {
  groups_.Clear();
}
inline const ::Group& QueryGroupAck::groups(int index) const {
  // @@protoc_insertion_point(field_get:QueryGroupAck.groups)
  return groups_.Get(index);
}
inline ::Group* QueryGroupAck::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:QueryGroupAck.groups)
  return groups_.Mutable(index);
}
inline ::Group* QueryGroupAck::add_groups() {
  // @@protoc_insertion_point(field_add:QueryGroupAck.groups)
  return groups_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Group >*
QueryGroupAck::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:QueryGroupAck.groups)
  return &groups_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Group >&
QueryGroupAck::groups() const {
  // @@protoc_insertion_point(field_list:QueryGroupAck.groups)
  return groups_;
}

// -------------------------------------------------------------------

// QueryMembers

// repeated uint32 gids = 1;
inline int QueryMembers::gids_size() const {
  return gids_.size();
}
inline void QueryMembers::clear_gids() {
  gids_.Clear();
}
inline ::google::protobuf::uint32 QueryMembers::gids(int index) const {
  // @@protoc_insertion_point(field_get:QueryMembers.gids)
  return gids_.Get(index);
}
inline void QueryMembers::set_gids(int index, ::google::protobuf::uint32 value) {
  gids_.Set(index, value);
  // @@protoc_insertion_point(field_set:QueryMembers.gids)
}
inline void QueryMembers::add_gids(::google::protobuf::uint32 value) {
  gids_.Add(value);
  // @@protoc_insertion_point(field_add:QueryMembers.gids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
QueryMembers::gids() const {
  // @@protoc_insertion_point(field_list:QueryMembers.gids)
  return gids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
QueryMembers::mutable_gids() {
  // @@protoc_insertion_point(field_mutable_list:QueryMembers.gids)
  return &gids_;
}

// optional .QueryMembers.DetailLevel detail = 2 [default = USER_INFO];
inline bool QueryMembers::has_detail() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryMembers::set_has_detail() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryMembers::clear_has_detail() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryMembers::clear_detail() {
  detail_ = 1;
  clear_has_detail();
}
inline ::QueryMembers_DetailLevel QueryMembers::detail() const {
  // @@protoc_insertion_point(field_get:QueryMembers.detail)
  return static_cast< ::QueryMembers_DetailLevel >(detail_);
}
inline void QueryMembers::set_detail(::QueryMembers_DetailLevel value) {
  assert(::QueryMembers_DetailLevel_IsValid(value));
  set_has_detail();
  detail_ = value;
  // @@protoc_insertion_point(field_set:QueryMembers.detail)
}

// -------------------------------------------------------------------

// QueryMembersAck_GroupMembers

// required uint32 gid = 1;
inline bool QueryMembersAck_GroupMembers::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryMembersAck_GroupMembers::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryMembersAck_GroupMembers::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryMembersAck_GroupMembers::clear_gid() {
  gid_ = 0u;
  clear_has_gid();
}
inline ::google::protobuf::uint32 QueryMembersAck_GroupMembers::gid() const {
  // @@protoc_insertion_point(field_get:QueryMembersAck.GroupMembers.gid)
  return gid_;
}
inline void QueryMembersAck_GroupMembers::set_gid(::google::protobuf::uint32 value) {
  set_has_gid();
  gid_ = value;
  // @@protoc_insertion_point(field_set:QueryMembersAck.GroupMembers.gid)
}

// repeated uint32 ingroups = 2;
inline int QueryMembersAck_GroupMembers::ingroups_size() const {
  return ingroups_.size();
}
inline void QueryMembersAck_GroupMembers::clear_ingroups() {
  ingroups_.Clear();
}
inline ::google::protobuf::uint32 QueryMembersAck_GroupMembers::ingroups(int index) const {
  // @@protoc_insertion_point(field_get:QueryMembersAck.GroupMembers.ingroups)
  return ingroups_.Get(index);
}
inline void QueryMembersAck_GroupMembers::set_ingroups(int index, ::google::protobuf::uint32 value) {
  ingroups_.Set(index, value);
  // @@protoc_insertion_point(field_set:QueryMembersAck.GroupMembers.ingroups)
}
inline void QueryMembersAck_GroupMembers::add_ingroups(::google::protobuf::uint32 value) {
  ingroups_.Add(value);
  // @@protoc_insertion_point(field_add:QueryMembersAck.GroupMembers.ingroups)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
QueryMembersAck_GroupMembers::ingroups() const {
  // @@protoc_insertion_point(field_list:QueryMembersAck.GroupMembers.ingroups)
  return ingroups_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
QueryMembersAck_GroupMembers::mutable_ingroups() {
  // @@protoc_insertion_point(field_mutable_list:QueryMembersAck.GroupMembers.ingroups)
  return &ingroups_;
}

// repeated uint32 outgroups = 3;
inline int QueryMembersAck_GroupMembers::outgroups_size() const {
  return outgroups_.size();
}
inline void QueryMembersAck_GroupMembers::clear_outgroups() {
  outgroups_.Clear();
}
inline ::google::protobuf::uint32 QueryMembersAck_GroupMembers::outgroups(int index) const {
  // @@protoc_insertion_point(field_get:QueryMembersAck.GroupMembers.outgroups)
  return outgroups_.Get(index);
}
inline void QueryMembersAck_GroupMembers::set_outgroups(int index, ::google::protobuf::uint32 value) {
  outgroups_.Set(index, value);
  // @@protoc_insertion_point(field_set:QueryMembersAck.GroupMembers.outgroups)
}
inline void QueryMembersAck_GroupMembers::add_outgroups(::google::protobuf::uint32 value) {
  outgroups_.Add(value);
  // @@protoc_insertion_point(field_add:QueryMembersAck.GroupMembers.outgroups)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
QueryMembersAck_GroupMembers::outgroups() const {
  // @@protoc_insertion_point(field_list:QueryMembersAck.GroupMembers.outgroups)
  return outgroups_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
QueryMembersAck_GroupMembers::mutable_outgroups() {
  // @@protoc_insertion_point(field_mutable_list:QueryMembersAck.GroupMembers.outgroups)
  return &outgroups_;
}

// repeated .User members = 4;
inline int QueryMembersAck_GroupMembers::members_size() const {
  return members_.size();
}
inline void QueryMembersAck_GroupMembers::clear_members() {
  members_.Clear();
}
inline const ::User& QueryMembersAck_GroupMembers::members(int index) const {
  // @@protoc_insertion_point(field_get:QueryMembersAck.GroupMembers.members)
  return members_.Get(index);
}
inline ::User* QueryMembersAck_GroupMembers::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:QueryMembersAck.GroupMembers.members)
  return members_.Mutable(index);
}
inline ::User* QueryMembersAck_GroupMembers::add_members() {
  // @@protoc_insertion_point(field_add:QueryMembersAck.GroupMembers.members)
  return members_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::User >*
QueryMembersAck_GroupMembers::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:QueryMembersAck.GroupMembers.members)
  return &members_;
}
inline const ::google::protobuf::RepeatedPtrField< ::User >&
QueryMembersAck_GroupMembers::members() const {
  // @@protoc_insertion_point(field_list:QueryMembersAck.GroupMembers.members)
  return members_;
}

// -------------------------------------------------------------------

// QueryMembersAck

// required int32 result = 1;
inline bool QueryMembersAck::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryMembersAck::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryMembersAck::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryMembersAck::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 QueryMembersAck::result() const {
  // @@protoc_insertion_point(field_get:QueryMembersAck.result)
  return result_;
}
inline void QueryMembersAck::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:QueryMembersAck.result)
}

// repeated .QueryMembersAck.GroupMembers members = 2;
inline int QueryMembersAck::members_size() const {
  return members_.size();
}
inline void QueryMembersAck::clear_members() {
  members_.Clear();
}
inline const ::QueryMembersAck_GroupMembers& QueryMembersAck::members(int index) const {
  // @@protoc_insertion_point(field_get:QueryMembersAck.members)
  return members_.Get(index);
}
inline ::QueryMembersAck_GroupMembers* QueryMembersAck::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:QueryMembersAck.members)
  return members_.Mutable(index);
}
inline ::QueryMembersAck_GroupMembers* QueryMembersAck::add_members() {
  // @@protoc_insertion_point(field_add:QueryMembersAck.members)
  return members_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::QueryMembersAck_GroupMembers >*
QueryMembersAck::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:QueryMembersAck.members)
  return &members_;
}
inline const ::google::protobuf::RepeatedPtrField< ::QueryMembersAck_GroupMembers >&
QueryMembersAck::members() const {
  // @@protoc_insertion_point(field_list:QueryMembersAck.members)
  return members_;
}

// -------------------------------------------------------------------

// JoinGroup

// required uint32 gid = 1;
inline bool JoinGroup::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinGroup::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinGroup::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinGroup::clear_gid() {
  gid_ = 0u;
  clear_has_gid();
}
inline ::google::protobuf::uint32 JoinGroup::gid() const {
  // @@protoc_insertion_point(field_get:JoinGroup.gid)
  return gid_;
}
inline void JoinGroup::set_gid(::google::protobuf::uint32 value) {
  set_has_gid();
  gid_ = value;
  // @@protoc_insertion_point(field_set:JoinGroup.gid)
}

// -------------------------------------------------------------------

// JoinGroupAck

// required int32 result = 1;
inline bool JoinGroupAck::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinGroupAck::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinGroupAck::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinGroupAck::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 JoinGroupAck::result() const {
  // @@protoc_insertion_point(field_get:JoinGroupAck.result)
  return result_;
}
inline void JoinGroupAck::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:JoinGroupAck.result)
}

// optional uint32 gid = 2;
inline bool JoinGroupAck::has_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinGroupAck::set_has_gid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinGroupAck::clear_has_gid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinGroupAck::clear_gid() {
  gid_ = 0u;
  clear_has_gid();
}
inline ::google::protobuf::uint32 JoinGroupAck::gid() const {
  // @@protoc_insertion_point(field_get:JoinGroupAck.gid)
  return gid_;
}
inline void JoinGroupAck::set_gid(::google::protobuf::uint32 value) {
  set_has_gid();
  gid_ = value;
  // @@protoc_insertion_point(field_set:JoinGroupAck.gid)
}

// -------------------------------------------------------------------

// LeaveGroup

// optional uint32 gid = 1;
inline bool LeaveGroup::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveGroup::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaveGroup::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaveGroup::clear_gid() {
  gid_ = 0u;
  clear_has_gid();
}
inline ::google::protobuf::uint32 LeaveGroup::gid() const {
  // @@protoc_insertion_point(field_get:LeaveGroup.gid)
  return gid_;
}
inline void LeaveGroup::set_gid(::google::protobuf::uint32 value) {
  set_has_gid();
  gid_ = value;
  // @@protoc_insertion_point(field_set:LeaveGroup.gid)
}

// -------------------------------------------------------------------

// LeaveGroupAck

// required int32 result = 1;
inline bool LeaveGroupAck::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveGroupAck::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaveGroupAck::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaveGroupAck::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 LeaveGroupAck::result() const {
  // @@protoc_insertion_point(field_get:LeaveGroupAck.result)
  return result_;
}
inline void LeaveGroupAck::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:LeaveGroupAck.result)
}

// optional uint32 gid = 2;
inline bool LeaveGroupAck::has_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LeaveGroupAck::set_has_gid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LeaveGroupAck::clear_has_gid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LeaveGroupAck::clear_gid() {
  gid_ = 0u;
  clear_has_gid();
}
inline ::google::protobuf::uint32 LeaveGroupAck::gid() const {
  // @@protoc_insertion_point(field_get:LeaveGroupAck.gid)
  return gid_;
}
inline void LeaveGroupAck::set_gid(::google::protobuf::uint32 value) {
  set_has_gid();
  gid_ = value;
  // @@protoc_insertion_point(field_set:LeaveGroupAck.gid)
}

// -------------------------------------------------------------------

// RequestMic

// optional uint32 gid = 1;
inline bool RequestMic::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestMic::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestMic::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestMic::clear_gid() {
  gid_ = 0u;
  clear_has_gid();
}
inline ::google::protobuf::uint32 RequestMic::gid() const {
  // @@protoc_insertion_point(field_get:RequestMic.gid)
  return gid_;
}
inline void RequestMic::set_gid(::google::protobuf::uint32 value) {
  set_has_gid();
  gid_ = value;
  // @@protoc_insertion_point(field_set:RequestMic.gid)
}

// optional uint32 uid = 2;
inline bool RequestMic::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestMic::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestMic::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestMic::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 RequestMic::uid() const {
  // @@protoc_insertion_point(field_get:RequestMic.uid)
  return uid_;
}
inline void RequestMic::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:RequestMic.uid)
}

// optional uint32 payload = 3;
inline bool RequestMic::has_payload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestMic::set_has_payload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestMic::clear_has_payload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestMic::clear_payload() {
  payload_ = 0u;
  clear_has_payload();
}
inline ::google::protobuf::uint32 RequestMic::payload() const {
  // @@protoc_insertion_point(field_get:RequestMic.payload)
  return payload_;
}
inline void RequestMic::set_payload(::google::protobuf::uint32 value) {
  set_has_payload();
  payload_ = value;
  // @@protoc_insertion_point(field_set:RequestMic.payload)
}

// -------------------------------------------------------------------

// RequestMicAck

// required int32 result = 1;
inline bool RequestMicAck::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestMicAck::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestMicAck::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestMicAck::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 RequestMicAck::result() const {
  // @@protoc_insertion_point(field_get:RequestMicAck.result)
  return result_;
}
inline void RequestMicAck::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:RequestMicAck.result)
}

// optional uint32 cookie = 2;
inline bool RequestMicAck::has_cookie() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestMicAck::set_has_cookie() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestMicAck::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestMicAck::clear_cookie() {
  cookie_ = 0u;
  clear_has_cookie();
}
inline ::google::protobuf::uint32 RequestMicAck::cookie() const {
  // @@protoc_insertion_point(field_get:RequestMicAck.cookie)
  return cookie_;
}
inline void RequestMicAck::set_cookie(::google::protobuf::uint32 value) {
  set_has_cookie();
  cookie_ = value;
  // @@protoc_insertion_point(field_set:RequestMicAck.cookie)
}

// -------------------------------------------------------------------

// ReleaseMic

// optional uint32 gid = 1;
inline bool ReleaseMic::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReleaseMic::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReleaseMic::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReleaseMic::clear_gid() {
  gid_ = 0u;
  clear_has_gid();
}
inline ::google::protobuf::uint32 ReleaseMic::gid() const {
  // @@protoc_insertion_point(field_get:ReleaseMic.gid)
  return gid_;
}
inline void ReleaseMic::set_gid(::google::protobuf::uint32 value) {
  set_has_gid();
  gid_ = value;
  // @@protoc_insertion_point(field_set:ReleaseMic.gid)
}

// optional uint32 uid = 2;
inline bool ReleaseMic::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReleaseMic::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReleaseMic::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReleaseMic::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 ReleaseMic::uid() const {
  // @@protoc_insertion_point(field_get:ReleaseMic.uid)
  return uid_;
}
inline void ReleaseMic::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:ReleaseMic.uid)
}

// -------------------------------------------------------------------

// ReleaseMicAck

// required int32 result = 1;
inline bool ReleaseMicAck::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReleaseMicAck::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReleaseMicAck::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReleaseMicAck::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ReleaseMicAck::result() const {
  // @@protoc_insertion_point(field_get:ReleaseMicAck.result)
  return result_;
}
inline void ReleaseMicAck::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:ReleaseMicAck.result)
}

// -------------------------------------------------------------------

// Call

// repeated uint32 uid = 1;
inline int Call::uid_size() const {
  return uid_.size();
}
inline void Call::clear_uid() {
  uid_.Clear();
}
inline ::google::protobuf::uint32 Call::uid(int index) const {
  // @@protoc_insertion_point(field_get:Call.uid)
  return uid_.Get(index);
}
inline void Call::set_uid(int index, ::google::protobuf::uint32 value) {
  uid_.Set(index, value);
  // @@protoc_insertion_point(field_set:Call.uid)
}
inline void Call::add_uid(::google::protobuf::uint32 value) {
  uid_.Add(value);
  // @@protoc_insertion_point(field_add:Call.uid)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Call::uid() const {
  // @@protoc_insertion_point(field_list:Call.uid)
  return uid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Call::mutable_uid() {
  // @@protoc_insertion_point(field_mutable_list:Call.uid)
  return &uid_;
}

// -------------------------------------------------------------------

// CallAck

// required int32 result = 1;
inline bool CallAck::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CallAck::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CallAck::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CallAck::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 CallAck::result() const {
  // @@protoc_insertion_point(field_get:CallAck.result)
  return result_;
}
inline void CallAck::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:CallAck.result)
}

// repeated uint32 uid = 2;
inline int CallAck::uid_size() const {
  return uid_.size();
}
inline void CallAck::clear_uid() {
  uid_.Clear();
}
inline ::google::protobuf::uint32 CallAck::uid(int index) const {
  // @@protoc_insertion_point(field_get:CallAck.uid)
  return uid_.Get(index);
}
inline void CallAck::set_uid(int index, ::google::protobuf::uint32 value) {
  uid_.Set(index, value);
  // @@protoc_insertion_point(field_set:CallAck.uid)
}
inline void CallAck::add_uid(::google::protobuf::uint32 value) {
  uid_.Add(value);
  // @@protoc_insertion_point(field_add:CallAck.uid)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CallAck::uid() const {
  // @@protoc_insertion_point(field_list:CallAck.uid)
  return uid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CallAck::mutable_uid() {
  // @@protoc_insertion_point(field_mutable_list:CallAck.uid)
  return &uid_;
}

// -------------------------------------------------------------------

// TempCallArrived

// required string call_name = 1;
inline bool TempCallArrived::has_call_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TempCallArrived::set_has_call_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TempCallArrived::clear_has_call_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TempCallArrived::clear_call_name() {
  call_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_call_name();
}
inline const ::std::string& TempCallArrived::call_name() const {
  // @@protoc_insertion_point(field_get:TempCallArrived.call_name)
  return call_name_.GetNoArena();
}
inline void TempCallArrived::set_call_name(const ::std::string& value) {
  set_has_call_name();
  call_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TempCallArrived.call_name)
}
#if LANG_CXX11
inline void TempCallArrived::set_call_name(::std::string&& value) {
  set_has_call_name();
  call_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TempCallArrived.call_name)
}
#endif
inline void TempCallArrived::set_call_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_call_name();
  call_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TempCallArrived.call_name)
}
inline void TempCallArrived::set_call_name(const char* value, size_t size) {
  set_has_call_name();
  call_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TempCallArrived.call_name)
}
inline ::std::string* TempCallArrived::mutable_call_name() {
  set_has_call_name();
  // @@protoc_insertion_point(field_mutable:TempCallArrived.call_name)
  return call_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TempCallArrived::release_call_name() {
  // @@protoc_insertion_point(field_release:TempCallArrived.call_name)
  clear_has_call_name();
  return call_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TempCallArrived::set_allocated_call_name(::std::string* call_name) {
  if (call_name != NULL) {
    set_has_call_name();
  } else {
    clear_has_call_name();
  }
  call_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), call_name);
  // @@protoc_insertion_point(field_set_allocated:TempCallArrived.call_name)
}

// -------------------------------------------------------------------

// TempCallStatus

// required uint32 call_status = 1;
inline bool TempCallStatus::has_call_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TempCallStatus::set_has_call_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TempCallStatus::clear_has_call_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TempCallStatus::clear_call_status() {
  call_status_ = 0u;
  clear_has_call_status();
}
inline ::google::protobuf::uint32 TempCallStatus::call_status() const {
  // @@protoc_insertion_point(field_get:TempCallStatus.call_status)
  return call_status_;
}
inline void TempCallStatus::set_call_status(::google::protobuf::uint32 value) {
  set_has_call_status();
  call_status_ = value;
  // @@protoc_insertion_point(field_set:TempCallStatus.call_status)
}

// -------------------------------------------------------------------

// Logout

// -------------------------------------------------------------------

// LogoutAck

// required int32 result = 1;
inline bool LogoutAck::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogoutAck::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogoutAck::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogoutAck::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 LogoutAck::result() const {
  // @@protoc_insertion_point(field_get:LogoutAck.result)
  return result_;
}
inline void LogoutAck::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:LogoutAck.result)
}

// -------------------------------------------------------------------

// ReportLocation

// required double longitude = 1;
inline bool ReportLocation::has_longitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReportLocation::set_has_longitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReportLocation::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReportLocation::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double ReportLocation::longitude() const {
  // @@protoc_insertion_point(field_get:ReportLocation.longitude)
  return longitude_;
}
inline void ReportLocation::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:ReportLocation.longitude)
}

// required double latitude = 2;
inline bool ReportLocation::has_latitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReportLocation::set_has_latitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReportLocation::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReportLocation::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double ReportLocation::latitude() const {
  // @@protoc_insertion_point(field_get:ReportLocation.latitude)
  return latitude_;
}
inline void ReportLocation::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:ReportLocation.latitude)
}

// -------------------------------------------------------------------

// ReportLocationAck

// required int32 result = 1;
inline bool ReportLocationAck::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReportLocationAck::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReportLocationAck::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReportLocationAck::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ReportLocationAck::result() const {
  // @@protoc_insertion_point(field_get:ReportLocationAck.result)
  return result_;
}
inline void ReportLocationAck::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:ReportLocationAck.result)
}

// -------------------------------------------------------------------

// Ping

// optional uint32 timestamp = 1;
inline bool Ping::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ping::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ping::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ping::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 Ping::timestamp() const {
  // @@protoc_insertion_point(field_get:Ping.timestamp)
  return timestamp_;
}
inline void Ping::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:Ping.timestamp)
}

// -------------------------------------------------------------------

// PingAck

// optional uint32 timestamp = 1;
inline bool PingAck::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PingAck::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PingAck::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PingAck::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 PingAck::timestamp() const {
  // @@protoc_insertion_point(field_get:PingAck.timestamp)
  return timestamp_;
}
inline void PingAck::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:PingAck.timestamp)
}

// -------------------------------------------------------------------

// LostMic

// required uint32 gid = 1;
inline bool LostMic::has_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LostMic::set_has_gid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LostMic::clear_has_gid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LostMic::clear_gid() {
  gid_ = 0u;
  clear_has_gid();
}
inline ::google::protobuf::uint32 LostMic::gid() const {
  // @@protoc_insertion_point(field_get:LostMic.gid)
  return gid_;
}
inline void LostMic::set_gid(::google::protobuf::uint32 value) {
  set_has_gid();
  gid_ = value;
  // @@protoc_insertion_point(field_set:LostMic.gid)
}

// required string reason = 2;
inline bool LostMic::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LostMic::set_has_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LostMic::clear_has_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LostMic::clear_reason() {
  reason_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reason();
}
inline const ::std::string& LostMic::reason() const {
  // @@protoc_insertion_point(field_get:LostMic.reason)
  return reason_.GetNoArena();
}
inline void LostMic::set_reason(const ::std::string& value) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LostMic.reason)
}
#if LANG_CXX11
inline void LostMic::set_reason(::std::string&& value) {
  set_has_reason();
  reason_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LostMic.reason)
}
#endif
inline void LostMic::set_reason(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LostMic.reason)
}
inline void LostMic::set_reason(const char* value, size_t size) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LostMic.reason)
}
inline ::std::string* LostMic::mutable_reason() {
  set_has_reason();
  // @@protoc_insertion_point(field_mutable:LostMic.reason)
  return reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LostMic::release_reason() {
  // @@protoc_insertion_point(field_release:LostMic.reason)
  clear_has_reason();
  return reason_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LostMic::set_allocated_reason(::std::string* reason) {
  if (reason != NULL) {
    set_has_reason();
  } else {
    clear_has_reason();
  }
  reason_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:LostMic.reason)
}

// -------------------------------------------------------------------

// Kickout

// required string reason = 1;
inline bool Kickout::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Kickout::set_has_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Kickout::clear_has_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Kickout::clear_reason() {
  reason_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reason();
}
inline const ::std::string& Kickout::reason() const {
  // @@protoc_insertion_point(field_get:Kickout.reason)
  return reason_.GetNoArena();
}
inline void Kickout::set_reason(const ::std::string& value) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Kickout.reason)
}
#if LANG_CXX11
inline void Kickout::set_reason(::std::string&& value) {
  set_has_reason();
  reason_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Kickout.reason)
}
#endif
inline void Kickout::set_reason(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Kickout.reason)
}
inline void Kickout::set_reason(const char* value, size_t size) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Kickout.reason)
}
inline ::std::string* Kickout::mutable_reason() {
  set_has_reason();
  // @@protoc_insertion_point(field_mutable:Kickout.reason)
  return reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Kickout::release_reason() {
  // @@protoc_insertion_point(field_release:Kickout.reason)
  clear_has_reason();
  return reason_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Kickout::set_allocated_reason(::std::string* reason) {
  if (reason != NULL) {
    set_has_reason();
  } else {
    clear_has_reason();
  }
  reason_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:Kickout.reason)
}

// -------------------------------------------------------------------

// Reconfigured

// required .Configure conf = 1;
inline bool Reconfigured::has_conf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reconfigured::set_has_conf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reconfigured::clear_has_conf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reconfigured::clear_conf() {
  if (conf_ != NULL) conf_->::Configure::Clear();
  clear_has_conf();
}
inline const ::Configure& Reconfigured::conf() const {
  const ::Configure* p = conf_;
  // @@protoc_insertion_point(field_get:Reconfigured.conf)
  return p != NULL ? *p : *reinterpret_cast<const ::Configure*>(
      &::_Configure_default_instance_);
}
inline ::Configure* Reconfigured::mutable_conf() {
  set_has_conf();
  if (conf_ == NULL) {
    conf_ = new ::Configure;
  }
  // @@protoc_insertion_point(field_mutable:Reconfigured.conf)
  return conf_;
}
inline ::Configure* Reconfigured::release_conf() {
  // @@protoc_insertion_point(field_release:Reconfigured.conf)
  clear_has_conf();
  ::Configure* temp = conf_;
  conf_ = NULL;
  return temp;
}
inline void Reconfigured::set_allocated_conf(::Configure* conf) {
  delete conf_;
  conf_ = conf;
  if (conf) {
    set_has_conf();
  } else {
    clear_has_conf();
  }
  // @@protoc_insertion_point(field_set_allocated:Reconfigured.conf)
}

// -------------------------------------------------------------------

// CurrentGroup

// required uint32 gid = 1;
inline bool CurrentGroup::has_gid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CurrentGroup::set_has_gid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CurrentGroup::clear_has_gid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CurrentGroup::clear_gid() {
  gid_ = 0u;
  clear_has_gid();
}
inline ::google::protobuf::uint32 CurrentGroup::gid() const {
  // @@protoc_insertion_point(field_get:CurrentGroup.gid)
  return gid_;
}
inline void CurrentGroup::set_gid(::google::protobuf::uint32 value) {
  set_has_gid();
  gid_ = value;
  // @@protoc_insertion_point(field_set:CurrentGroup.gid)
}

// required string reason = 2;
inline bool CurrentGroup::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CurrentGroup::set_has_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CurrentGroup::clear_has_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CurrentGroup::clear_reason() {
  reason_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reason();
}
inline const ::std::string& CurrentGroup::reason() const {
  // @@protoc_insertion_point(field_get:CurrentGroup.reason)
  return reason_.GetNoArena();
}
inline void CurrentGroup::set_reason(const ::std::string& value) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CurrentGroup.reason)
}
#if LANG_CXX11
inline void CurrentGroup::set_reason(::std::string&& value) {
  set_has_reason();
  reason_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CurrentGroup.reason)
}
#endif
inline void CurrentGroup::set_reason(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CurrentGroup.reason)
}
inline void CurrentGroup::set_reason(const char* value, size_t size) {
  set_has_reason();
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CurrentGroup.reason)
}
inline ::std::string* CurrentGroup::mutable_reason() {
  set_has_reason();
  // @@protoc_insertion_point(field_mutable:CurrentGroup.reason)
  return reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CurrentGroup::release_reason() {
  // @@protoc_insertion_point(field_release:CurrentGroup.reason)
  clear_has_reason();
  return reason_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CurrentGroup::set_allocated_reason(::std::string* reason) {
  if (reason != NULL) {
    set_has_reason();
  } else {
    clear_has_reason();
  }
  reason_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:CurrentGroup.reason)
}

// required string gname = 3;
inline bool CurrentGroup::has_gname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CurrentGroup::set_has_gname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CurrentGroup::clear_has_gname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CurrentGroup::clear_gname() {
  gname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gname();
}
inline const ::std::string& CurrentGroup::gname() const {
  // @@protoc_insertion_point(field_get:CurrentGroup.gname)
  return gname_.GetNoArena();
}
inline void CurrentGroup::set_gname(const ::std::string& value) {
  set_has_gname();
  gname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CurrentGroup.gname)
}
#if LANG_CXX11
inline void CurrentGroup::set_gname(::std::string&& value) {
  set_has_gname();
  gname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:CurrentGroup.gname)
}
#endif
inline void CurrentGroup::set_gname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_gname();
  gname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CurrentGroup.gname)
}
inline void CurrentGroup::set_gname(const char* value, size_t size) {
  set_has_gname();
  gname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CurrentGroup.gname)
}
inline ::std::string* CurrentGroup::mutable_gname() {
  set_has_gname();
  // @@protoc_insertion_point(field_mutable:CurrentGroup.gname)
  return gname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CurrentGroup::release_gname() {
  // @@protoc_insertion_point(field_release:CurrentGroup.gname)
  clear_has_gname();
  return gname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CurrentGroup::set_allocated_gname(::std::string* gname) {
  if (gname != NULL) {
    set_has_gname();
  } else {
    clear_has_gname();
  }
  gname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gname);
  // @@protoc_insertion_point(field_set_allocated:CurrentGroup.gname)
}

// -------------------------------------------------------------------

// GroupListChanged

// repeated .Group update_groups = 1;
inline int GroupListChanged::update_groups_size() const {
  return update_groups_.size();
}
inline void GroupListChanged::clear_update_groups() {
  update_groups_.Clear();
}
inline const ::Group& GroupListChanged::update_groups(int index) const {
  // @@protoc_insertion_point(field_get:GroupListChanged.update_groups)
  return update_groups_.Get(index);
}
inline ::Group* GroupListChanged::mutable_update_groups(int index) {
  // @@protoc_insertion_point(field_mutable:GroupListChanged.update_groups)
  return update_groups_.Mutable(index);
}
inline ::Group* GroupListChanged::add_update_groups() {
  // @@protoc_insertion_point(field_add:GroupListChanged.update_groups)
  return update_groups_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Group >*
GroupListChanged::mutable_update_groups() {
  // @@protoc_insertion_point(field_mutable_list:GroupListChanged.update_groups)
  return &update_groups_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Group >&
GroupListChanged::update_groups() const {
  // @@protoc_insertion_point(field_list:GroupListChanged.update_groups)
  return update_groups_;
}

// repeated uint32 rm_groups = 2;
inline int GroupListChanged::rm_groups_size() const {
  return rm_groups_.size();
}
inline void GroupListChanged::clear_rm_groups() {
  rm_groups_.Clear();
}
inline ::google::protobuf::uint32 GroupListChanged::rm_groups(int index) const {
  // @@protoc_insertion_point(field_get:GroupListChanged.rm_groups)
  return rm_groups_.Get(index);
}
inline void GroupListChanged::set_rm_groups(int index, ::google::protobuf::uint32 value) {
  rm_groups_.Set(index, value);
  // @@protoc_insertion_point(field_set:GroupListChanged.rm_groups)
}
inline void GroupListChanged::add_rm_groups(::google::protobuf::uint32 value) {
  rm_groups_.Add(value);
  // @@protoc_insertion_point(field_add:GroupListChanged.rm_groups)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GroupListChanged::rm_groups() const {
  // @@protoc_insertion_point(field_list:GroupListChanged.rm_groups)
  return rm_groups_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GroupListChanged::mutable_rm_groups() {
  // @@protoc_insertion_point(field_mutable_list:GroupListChanged.rm_groups)
  return &rm_groups_;
}

// -------------------------------------------------------------------

// MemberGetMic

// required uint32 gid = 1;
inline bool MemberGetMic::has_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemberGetMic::set_has_gid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemberGetMic::clear_has_gid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemberGetMic::clear_gid() {
  gid_ = 0u;
  clear_has_gid();
}
inline ::google::protobuf::uint32 MemberGetMic::gid() const {
  // @@protoc_insertion_point(field_get:MemberGetMic.gid)
  return gid_;
}
inline void MemberGetMic::set_gid(::google::protobuf::uint32 value) {
  set_has_gid();
  gid_ = value;
  // @@protoc_insertion_point(field_set:MemberGetMic.gid)
}

// required uint32 uid = 2;
inline bool MemberGetMic::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemberGetMic::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemberGetMic::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemberGetMic::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 MemberGetMic::uid() const {
  // @@protoc_insertion_point(field_get:MemberGetMic.uid)
  return uid_;
}
inline void MemberGetMic::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:MemberGetMic.uid)
}

// optional string name = 3;
inline bool MemberGetMic::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemberGetMic::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemberGetMic::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemberGetMic::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& MemberGetMic::name() const {
  // @@protoc_insertion_point(field_get:MemberGetMic.name)
  return name_.GetNoArena();
}
inline void MemberGetMic::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MemberGetMic.name)
}
#if LANG_CXX11
inline void MemberGetMic::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MemberGetMic.name)
}
#endif
inline void MemberGetMic::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MemberGetMic.name)
}
inline void MemberGetMic::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MemberGetMic.name)
}
inline ::std::string* MemberGetMic::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:MemberGetMic.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MemberGetMic::release_name() {
  // @@protoc_insertion_point(field_release:MemberGetMic.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MemberGetMic::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MemberGetMic.name)
}

// -------------------------------------------------------------------

// MemberLostMic

// required uint32 gid = 1;
inline bool MemberLostMic::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemberLostMic::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemberLostMic::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemberLostMic::clear_gid() {
  gid_ = 0u;
  clear_has_gid();
}
inline ::google::protobuf::uint32 MemberLostMic::gid() const {
  // @@protoc_insertion_point(field_get:MemberLostMic.gid)
  return gid_;
}
inline void MemberLostMic::set_gid(::google::protobuf::uint32 value) {
  set_has_gid();
  gid_ = value;
  // @@protoc_insertion_point(field_set:MemberLostMic.gid)
}

// required uint32 uid = 2;
inline bool MemberLostMic::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemberLostMic::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemberLostMic::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemberLostMic::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 MemberLostMic::uid() const {
  // @@protoc_insertion_point(field_get:MemberLostMic.uid)
  return uid_;
}
inline void MemberLostMic::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:MemberLostMic.uid)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Group_GroupType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Group_GroupType>() {
  return ::Group_GroupType_descriptor();
}
template <> struct is_proto_enum< ::QueryGroup_DetailLevel> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::QueryGroup_DetailLevel>() {
  return ::QueryGroup_DetailLevel_descriptor();
}
template <> struct is_proto_enum< ::QueryMembers_DetailLevel> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::QueryMembers_DetailLevel>() {
  return ::QueryMembers_DetailLevel_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ptt_2eproto__INCLUDED
